Построение связующего дерева выполняется в несколько этапов.
#################### Этап 1 ####################
На первом этапе выбирается коммутатор, который будет выполнять роль корня (root) данного дерева.
Корнем (RB - root bridge) выбирается коммутатор, имеющий наименьший BID (Bridge ID).
BID коммутатора представляет собой 8-байтовое число, которое состоит из двух частей. Первая часть (два байта) - это приоритет.
Приоритет по умолчанию устанавливается достаточно высокий - 32768 (в десятичной нотации) или 0х8000 (то же число в шестнадцатеричном виде).
Вторая часть - это MAC-адрес коммутатора (6 байтов), поэтому при использовании значений по умолчанию корневым коммутатором может оказаться не самый производительный из них.
С помощью значения приоритета наименьший BID можно установить на заранее выбранном коммутаторе.
При изменении приоритета нужно учитывать, что значение приоритета - это не самостоятельное число, а первые два байта из восьмибайтового числа.
Т.е. значение приоритета, если его задавать в формате десятичного числа, должно нацело делиться на 4096.

Например. Bridge ID одного коммутатора 8000.00:11:22:33:44:55 (где 8000 - это приоритет в hex-формате (или 32768 в десятичном виде), а 00:11:22:33:44:55 - MAC-адрес),
Bridge ID другого - 7000.11:22:33:44:55:66.
Если сравнивать BID 8000.00:11:22:33:44:55 и 7000.11:22:33:44:55:66, то в результате сравнения двух шестнадцатеричных чисел 8000001122334455 > 7000112233445566,
следовательно второй победит на выборах корневого.
Так как приоритет - это старшие байты в BID, именно он имеет первостепенное значение.

Чтобы повлиять на процесс выборов корневого и резервного корневого коммутатора, задача администратора сети
заключается в том, чтобы на коммутаторе, который должен стать корневым, выставить приоритет так, чтобы его BID был минимальным,
а на резервном - так, чтобы его BID был больше чем у корневого, но меньше чем на всех остальных коммутаторах, у которых приоритет по умолчанию 0х8000.

#################### Этап 2 ####################
Остальные коммутаторы определяют какие интерфейсы останутся активными, какие будут заблокированы для передачи пользовательского трафика.
На корневом коммутаторе не блокируются никакие интерфейсы.
Остальные коммутаторы для определения, какие интерфейсы блокировать, используют понятие "стоимости корневого пути (или маршрута)",
позволяющее из нескольких путей выбрать наилучший с точки зрения скорости передачи.
Поскольку для резервных каналов могут использоваться линии связи с меньшей пропускной способностью, чем основные, крайне желательно,
чтобы протокол построения связующего дерева не блокировал более скоростные каналы.
Поэтому при расчете того, какие интерфейсы оставить активными, используются два параметра: количество переходов до корневого коммутатора и стоимость пути.
На самом деле, коммутаторы используют только стоимость пути, которая вычисляется сложением стоимостей всех отрезков пути между текущим и корневым коммутатором.
Соответственно, выбирается путь с наименьшей стоимостью.
Стоимость пути для каждого типа порта определяется стандартом.
В настоящее время стоимости определены так, как показано в таблице ниже, а в дальнейшем, скорее всего, будут еще не один раз пересмотрены.
Скорость передачи 	Стоимость
10 Мбит/сек 	           100
100 Мбит/сек 	            19
1 Гбит/сек 	            4
10 Гбит/сек 	            2

Стоимость пути на каком-либо участке сети коммутатор определяет как стоимость своего исходящего порта по направлению пути следования кадра в сторону корневого коммутатора.
Стоимость для конкретного порта коммутатора можно задать отличной от стандартной и таким образом управлять выбором корневого маршрута.

############################## Настройка STP на OpenvSwitch ##############################
Во всех командах в примерах используется br0, в реальных конфигурациях для настройки нужно указывать тот бридж,
который реально задействован в вашем коммутаторе, тот, в котором находятся нужные вам интерфейсы.
Для включения протокола STP в OpenVSwitch используется команда:
ovs-vsctl set Bridge br0 stp_enable=true
ovs-vsctl set bridge br0 stp_enable=true

Для выключения используется команда:
ovs-vsctl set Bridge br0 stp_enable=false

Для того, чтобы корнем дерева стал заранее выбранный производительный коммутатор (а при его отказе другой выбранный тоже заранее),
необходимо на этих коммутаторах задать приоритет для STP. В OpenVSwitch приоритет задается командой:
ovs-vsctl set Bridge br0 other_config:stp-priority=0x7000
Как вы видите, этой командой задается пониженный приоритет (по умолчанию 0x8000), для того, чтобы данный коммутатор выиграл выборы корневого коммутатора.

Для более точного определения, по каким путям будет проходить пользовательский трафик в результате построения связующего дерева,
можно задавать стоимость интерфейса, отличающуюся от стандартной. Стоимость задается командой:
ovs-vsctl set Port eth0 other_config:stp-path-cost=10

Таймеры по умолчанию можно изменить:
    - изменение таймера MaxAge (по умолчанию 20 сек):
    ovs-vsctl set Bridge br0 other_config:stp-max-age=10
    
    - изменение таймера ForwardDelay (по умолчанию 15 сек):
    ovs-vsctl set Bridge br0 other_config:stp-forward-delay=10
    
Таймеры достаточно устанавливать только на корневом и запасном корневом коммутаторах.
Текущие настройки коммутатора можно посмотреть с помощью команды:
ovs-vsctl list bridge

Посмотреть статус портов можно с помощью команды:
ovs-ofctl show br0

#################### Пример настройки STP на OVS ####################
У нас есть три коммутатора: Core I, Core II и Edge. Нам нужно, чтобы коммутаторы Core I и Core II обменивались между собой, а коммутатор Edge в нормальном состоянии передавал данные через коммутатор Core I, а в случае пропадания связи с коммутатором Core I - переключался на передачу данных через коммутатор Core II. А при восстановлении соединения, возвращался обратно на Core I. Для реализации данной схемы необходимо, чтобы Core I был корневым коммутатором, Core II - резервным корневым коммутатором, а Edge не становился корневым коммутатором ни при каких обстоятельствах. Для этого мы поставим приоритет на Core I - 0x6000, на Core II - 0x7000, а на Edge оставим приоритет по умолчанию. Создадим на всех трех коммутаторах Bridge br0 и добавим в него оба сетевых интерфейса (как создавать бридж и добавлять в него интерфейсы мы рассматривали ранее в практикуме).

Включим STP на коммутаторе Core I и сразу же установим на нем приоритет.
ovs-vsctl set Bridge br0 stp_enable=true
ovs-vsctl set Bridge br0 other_config:stp-priority=0x6000

Далее включим STP на коммутаторе Core II и тоже сразу же установим на нем приоритет.
ovs-vsctl set Bridge br0 stp_enable=true
ovs-vsctl set Bridge br0 other_config:stp-priority=0x7000

Наконец, включим STP на коммутаторе Edge.
ovs-vsctl set Bridge br0 stp_enable=true

Теперь зададим стоимость одного из исходящих интерфейсов на коммутаторе Edge.
Задавая большое значение стоимости порта мы определяем преимущественный путь трафика через другой порт коммутатора Edge.
ovs-vsctl set Port eth3 other_config:stp-path-cost=150

Посмотрим, как применились все настройки с помощью команды:
ovs-vsctl list bridge

Посмотреть статус портов можно с помощью команды:
ovs-ofctl show br0

#################### Настройка RSTP на OVS ####################
# Протокол RSTP настраивается аналогично, но с небольшими изменениями. Для включения протокола RSTP в OpenVSwitch используется команда:
ovs-vsctl set Bridge br0 rstp_enable=true

# Для выключения протокола RSTP в OpenVSwitch используется команда:
ovs-vsctl set Bridge br0 rstp_enable=false

# Приоритет коммутатора в RSTP задается в десятичном виде. Поэтому внимательно нужно проверять, чтобы задаваемое значение делилось нацело на 4096:
ovs-vsctl set Bridge br0 other_config:rstp-priority=28672

# Таймеры по умолчанию можно изменить командами:
ovs-vsctl set Bridge br0 other_config:rstp-max-age=10
ovs-vsctl set Bridge br0 other_config:rstp-forward-delay=10

# Стоимость пути через интерфейс определяется командой:
ovs-vsctl set Port eth0 other_config:rstp-path-cost=150

#################### Пример настройки RSTP на OVS ####################
У нас есть три коммутатора: Core I, Core II и Edge. Задача аналогичная предыдущей.
Нужно, чтобы коммутаторы Core I и Core II обменивались между собой, а коммутатор Edge в нормальном состоянии передавал данные через коммутатор Core I, а в случае пропадания связи с коммутатором Core I - переключался на передачу данных через коммутатор Core II. А при восстановлении соединения, возвращался обратно на Core I. Bridge на всех коммутаторах уже созданы, интерфейсы в них добавлены.

Включаем RSTP на коммутаторе Core I и сразу же установим на нем приоритет. (Проверяем, чтобы десятичное значение приоритета было кратным 4096)
ovs-vsctl set Bridge br0 rstp_enable=true
ovs-vsctl set Bridge br0 other_config:rstp-priority=24576

Далее включим RSTP на коммутаторе Core II и тоже сразу же установим на нем приоритет. (Также проверяем, чтобы десятичное значение приоритета было кратным 4096)
ovs-vsctl set Bridge br0 rstp_enable=true
ovs-vsctl set Bridge br0 other_config:rstp-priority=28672

Наконец, включим RSTP на коммутаторе Edge.
ovs-vsctl set Bridge br0 rstp_enable=true


назад
NET 08: Петли коммутации. Протокол STP
Описание:

Всем привет! Мы продолжаем изучать технологии канального уровня. В этом задании будем разбираться с вопросом резервирования каналов между коммутаторами в локальных сетях. Если соединить несколько коммутаторов между собой резервными линками - с одной стороны это приведет к повышению надежности топологии в целом, с другой - к проблемам, возникающим из-за так называемого "кольца" или "петли" коммутации, где могут зацикливаться пересылаемые кадры. О природе таких проблем и о методах борьбы с ними - протоколом STP и его более новой модификации RSTP, пойдет речь в теме этого задания.
Топологии с избыточностью

Вы уже знаете, как организована передача кадров в сети Ethernet. Также Вы знакомы с основными типами топологий. В рамках этого задания нас будут интересовать топологии с избыточностью:

Рисунок 1-3.

Для подробного рассмотрения мы воспользуемся простой схемой, в которой (рис. 4) коммутатор Edge подключен одновременно к двум коммутаторам Core I и Core II, которые, в свою очередь, соединены между собой. В случае обрыва соединения, например, между коммутатором Edge и коммутатором Core I, рабочей станции, подключенной к коммутатору Edge, все еще будут доступны сервера, подключенные к коммутаторам Core I и Core II.

Рисунок 4.
Проблемы топологий с избыточностью

Помимо обеспечения большей надежности на физическом уровне, топологии с избыточностью на канальном уровне могут приводить к возникновению таких проблем, как:

    широковещательный шторм,
    неустойчивость таблиц MAC-адресов и перегрузке сетевых интерфейсов всех устройств, подключенных к сети.

Рассмотрим эти проблемы подробнее.
Широковещательный шторм (broadcast storm)

Как вы уже знаете, коммутатор, когда получает кадр, адресованный на широковещательный адрес (FF:FF:FF:FF:FF:FF), т.е. предназначенный для получения всем узлам в сети, отправляет его через все свои интерфейсы, за исключением того, с которого пришел данный кадр. Рассмотрим рисунок (рис. 5)

Рисунок 5.

Допустим, с рабочей станции поступил широковещательный запрос (например, ARP-запрос) на коммутатор Edge (на рисунке - стрелка с номером 1). Коммутатор Edge перенаправил данный запрос на все свои порты, за исключением того, откуда пришел данный запрос (стрелки с номером 2).

Коммутаторы Core I и Core II, в свою очередь, поступают так же - перенаправляют кадр на все интерфейсы, кроме того, откуда он пришел (стрелки с номером 3). На этом этапе мы видим, что коммутаторы Core I и Core II переслали этот кадр друг другу. Но коммутаторы не имеют средств для понимания того, что это один и тот же кадр. Поэтому на следующем же этапе ситуация выглядит следующим образом (стрелки с номером 4): кадр вернулся на коммутатор Edge, на этот раз через два разных интерфейса, причем ни через один из них он не был получен изначально. С точки зрения коммутатора это два разных широковещательных кадра, каждый из которых нужно опять переслать через все свои порты, за исключением тех, откуда они пришли. Кадр пошел по кругу (стрелки с номером 5). Причем, даже по двойному сразу.

В технологии Ethernet не предусмотрены механизмы для предотвращения зацикливания кадра в сети. Точнее единственный механизм, который для этого предусмотрен, как раз и состоит в том, чтобы кадр не уходил обратно, откуда пришел. Но, как мы видим, в топологиях с резервными каналами, кадр может ходить по кругу бесконечно, не возвращаясь оттуда, откуда пришел, зато дублируясь на каждом этапе. В скором времени все коммутаторы сети будут заняты в основном передачей копии первоначального широковещательного кадра. Эта ситуация называется широковещательный шторм (broadcast storm) и, очевидно, приводит к неработоспособности сети в целом.
Неустойчивость таблицы MAC-адресов

Но это не единственная проблема. Как мы уже знаем, коммутатор определяет, на какой исходящий порт направлять кадр на основании таблицы MAC-адресов, которую строит, изучая адрес отправителя (source MAC address) кадра, пришедшего на порт. Вернемся к схеме, демонстрирующей широковещательный шторм. На этот раз на ней показано содержимое таблиц MAC-адресов на двух коммутаторах на определенных этапах (рис. 6). В первой колонке цифра соотносится с номерами на стрелках, вторая колонка содержит во всех случаях один MAC-адрес - это MAC-адрес ноутбука, отправившего изначальный запрос, в третьей колонке, как и в реальных таблицах, указывается интерфейс, через который нужно пересылать кадры для этого MAC-адреса, но так, как они будут выглядеть на каждом этапе.

Рисунок 6.

Мы наблюдаем на ней путешествие одного и того же кадра, имеющего широковещательный MAC-адрес получателя и конкретный MAC-адрес отправителя. Но обратите внимание: через тот порт коммутатора, к которому подключен отправитель, этот кадр прошел только один раз, в самом начале. В дальнейшем он появляется на коммутаторе Edge через два разных интерфейса, причем, ни один из них не является правильным! Но и на коммутаторах Core I и Core II появление данного кадра через разные интерфейсы приводит к изменениям записей в таблицах MAC-адресов. Причем, очень быстрым изменениям, при каждом появлении данного кадра с другого интерфейса. В результате ни один из коммутаторов не понимает, куда нужно отправлять кадры для данного MAC-адреса. Данное явление называется неустойчивостью таблиц MAC-адресов и тоже приводит к неработоспособности сети.
Переполнение входного стека сетевых интерфейсов устройств

Следствием широковещательного шторма является переполнение входного стека сетевых интерфейсов всех устройств, подключенных к сети. Поскольку любое устройство обязано обрабатывать все поступающие широковещательные кадры, а для их обработки всегда задействуется ресурсы центрального процессора. Поэтому широковещательный шторм приводит не только к деградации в работе сети, но и к чрезмерной загруженности устройств, подключенных к сети.
Протокол STP

Для решения вышеописанных проблем при сохранении возможности обеспечения резервных путей на физическом уровне, еще в 1985 году был предложен протокол STP (Spanning Tree Protocol - протокол связующего дерева, иногда встречается перевод "протокол остовного дерева"). Принят в качестве стандарта IEEE 802.1D в 1990 году (в 2004 году принят измененный стандарт), и чуть позже более современная версия - RSTP (Rapid STP), принят в качестве стандарта IEEE 802.1w в 2001 году.

STP и RSTP - это протоколы канального уровня модели OSI. Общая идея работы этих протоколов состоит в том, чтобы программно отключить некоторые интерфейсы таким образом, чтобы между любыми двумя устройствами существовал единственный путь, например, как показано на рисунке (рис. 7), т.е. чтобы "разорвать" кольцо. В случае физического отказа оборудования или линии связи, задействованных в основном пути, отключенные интерфейсы задействуются, а связующее дерево перестраивается с использованием резервных путей.

Рисунок 7.

Построение связующего дерева выполняется в несколько этапов.

На первом этапе выбирается коммутатор, который будет выполнять роль корня (root) данного дерева. Корнем (RB - root bridge) выбирается коммутатор, имеющий наименьший BID (Bridge ID). BID коммутатора представляет собой 8-байтовое число, которое состоит из двух частей. Первая часть (два байта) - это приоритет. Приоритет по умолчанию устанавливается достаточно высокий - 32768 (в десятичной нотации) или 0х8000 (то же число в шестнадцатеричном виде). Вторая часть - это MAC-адрес коммутатора (6 байтов), поэтому при использовании значений по умолчанию корневым коммутатором может оказаться не самый производительный из них. С помощью значения приоритета наименьший BID можно установить на заранее выбранном коммутаторе. При изменении приоритета нужно учитывать, что значение приоритета - это не самостоятельное число, а первые два байта из восьмибайтового числа. Т.е. значение приоритета, если его задавать в формате десятичного числа, должно нацело делиться на 4096.

Например. Bridge ID одного коммутатора 8000.00:11:22:33:44:55 (где 8000 - это приоритет в hex-формате (или 32768 в десятичном виде), а 00:11:22:33:44:55 - MAC-адрес), Bridge ID другого - 7000.11:22:33:44:55:66. Если сравнивать BID 8000.00:11:22:33:44:55 и 7000.11:22:33:44:55:66, то в результате сравнения двух шестнадцатеричных чисел 8000001122334455 > 7000112233445566, следовательно второй победит на выборах корневого. Так как приоритет - это старшие байты в BID, именно он имеет первостепенное значение. Если приоритет у двух коммутаторов одинаковый, то всё будут решать оставшиеся 6 байт MAC-адреса в BID. Именно поэтому, чтобы повлиять на процесс выборов корневого и резервного корневого коммутатора, задача администратора сети - на коммутаторе, который должен стать корневым, выставить приоритет так, чтобы его BID был минимальным, на резервном - так, чтобы его BID был больше чем у корневого, но меньше чем на всех остальных коммутаторах, у которых приоритет по умолчанию 0х8000.

На следующем этапе остальные коммутаторы определяют какие интерфейсы останутся активными, какие будут заблокированы для передачи пользовательского трафика. На корневом коммутаторе не блокируются никакие интерфейсы. Остальные коммутаторы для определения, какие интерфейсы блокировать, используют понятие "стоимости корневого пути (или маршрута)", позволяющее из нескольких путей выбрать наилучший с точки зрения скорости передачи. Поскольку для резервных каналов могут использоваться линии связи с меньшей пропускной способностью, чем основные, крайне желательно, чтобы протокол построения связующего дерева не блокировал более скоростные каналы. Поэтому при расчете того, какие интерфейсы оставить активными, используются два параметра: количество переходов до корневого коммутатора и стоимость пути. На самом деле, коммутаторы используют только стоимость пути, которая вычисляется сложением стоимостей всех отрезков пути между текущим и корневым коммутатором. Соответственно, выбирается путь с наименьшей стоимостью.

Стоимость пути для каждого типа порта определяется стандартом. Изначально было определено, что стоимость расчитывается как 1000, деленная на скорость порта в Мбит/с, но это правило уже довольно плохо работало с интерфейсами 1 Гбит/с и совсем никак с интерфейсами с большей пропускной способностью, поэтому было принято решение стандартные стоимости зафиксировать. В настоящее время стоимости определены так, как показано в таблице ниже, а в дальнейшем, скорее всего, будут еще не один раз пересмотрены.
Скорость передачи 	Стоимость
10 Мбит/сек 	100
100 Мбит/сек 	19
1 Гбит/сек 	4
10 Гбит/сек 	2

Стоимость пути на каком-либо участке сети коммутатор определяет как стоимость своего исходящего порта по направлению пути следования кадра в сторону корневого коммутатора. Стоимость для конкретного порта коммутатора можно задать отличной от стандартной и таким образом управлять выбором корневого маршрута.

Рассмотрим рисунок (рис. 8). Коммутатор, выбранный корнем, отмечен как Root. Число возле каждого соединения - его стоимость.

Рисунок 8.

Рассмотрим самый нижний коммутатор, который может иметь до корневого четыре варианта пути с различной стоимостью:

    самый короткий (через красные линки): 2 + 19 = 21,
    через 1 красный и 3 фиолетовых линка: 2 + 4 + 4 + 19 = 29,
    через 1 красный и 2 голубых линка: 2 + 4 + 19 = 25,
    самый длинный (через фиолетовые и голубые линки): 2 + 4 + 4 + 4 + 19 = 33.

В ситуации, когда все линии связи работоспособны и доступны, очевидно, что кратчайший путь - это путь через красные линки, имеющий стоимость 21. Этот путь и выбран при построении дерева.

Какой интерфейс будет заблокирован на неиспользуемом участке сети также определяется стоимостью. Блокируется тот интерфейс, для которого стоимость до корневого коммутатора будет наибольшей. Т.е. будут заблокированы интерфейсы так, как показано на рисунке 7. Как это происходит?

Коммутаторы обмениваются между собой сообщениями BPDU (Bridge Protocol Data Unit) "Hello". Эти сообщения беспрепятственно проходят между всеми работающими интерфейсами всех коммутаторов, даже тех, которые заблокированы для передачи пользовательского трафика. Сообщения пересылаются между коммутаторами с интервалом установленного таймера Hello (по умолчанию 2 секунды) и выполняют сразу три важные функции:

    Определяют доступность соседнего коммутатора через данный интерфейс
    Используются для выборов корневого коммутатора
    Используются для подсчета стоимости пути до корневого коммутатора

Для выполнения всех трех функций эти сообщения содержат 4 поля:

    BID корневого коммутатора
    BID коммутатора, пославшего это сообщение
    Стоимость пути до корневого коммутатора, включая стоимость выходного интерфейса коммутатора
    Значения таймера на корневом коммутаторе

Сообщения BPDU Hello, отправленные одним коммутатором, не пересылаются другим. Каждое такое сообщение коммутатор получает, анализирует и на его основе создает свои сообщения BPDU Hello, которые рассылает через все свои работающие интерфейсы, кроме того, через который получил именно это сообщение. Но может быть отправлено сообщение BPDU, созданное на основе BPDU, полученного через другой интерфейс.

Коммутатор устанавливает свой BID во второе поле. Если он обнаруживает, что его BID меньше, чем указанный в BPDU BID корневого коммутатора, то коммутатор подставляет свой BID в первое поле; если нет - то оставляет тот BID корневого коммутатора, который получил. Таким нехитрым способом происходят выборы корневого коммутатора. Если коммутатор ставит свой BID в первое поле, то в четвертом поле указывает значения своих таймеров. Если нет, то оставляет те значения, которые получил, и устанавливает их у себя. Значения таймеров по умолчанию:
Таймер 	Значение по умолчанию 	Что определяет
Hello 	2 сек 	интервал между BPDU
MaxAge 	10 * Hello 	время, через которое коммутатор считает, что канал недоступен, и начинает процесс перестроения связующего дерева
ForwardDelay 	15 сек 	время, на которое интерфейс задерживается на переходных состояниях

Если коммутатор не получает сообщение BPDU Hello через какой-либо интерфейс на протяжении времени, установленного таймером MaxAge, коммутатор считает, что линк через данный интерфейс больше не доступен и инициализирует процесс перестроения дерева STP.

На комутаторах в STP-топологии интерфейсы могут находиться с следующих состояниях:

    Blocking (заблокирован) - интерфейс не перенаправляет пользовательский трафик, только сообщения BPDU (и некоторые другие служебные сообщения протоколов)
    Listening - интерфейс все еще не перенаправляет пользовательский трафик, а перестраивает связующее дерево
    Learning - интерфейс все еще не перенаправляет пользовательский трафик, но получает его, и на его основе строит таблицу MAC-адресов
    Forwarding - интерфейс переходит в полностью рабочее положение, в котором передает пользовательский трафик

Состояния Blocking и Forwarding являются стабильными. В стабильно работающей сети все интерфейсы находятся в одном из этих двух состояниях, а обмен сообщениями BPDU выполняет только функцию контроля работоспособности всех интерфейсов.

Состояния Listening и Learning являются переходными и последовательно включаются при перестроении связующего дерева, когда появляется необходимость интерфейс из состояния Blocking перевести в состояние Forwarding.

В состоянии Listening интерфейс не пересылает пользовательский трафик, а уничтожает свою старую таблицу MAC-адресов и очищает кэш. В это же время происходит перестроение связующего дерева. Строго говоря, в состоянии Listening (а затем Learning) переходит не только ранее блокированный интерфейс, но и все интерфейсы всех коммутаторов сети. На этой стадии не происходит передачи пользовательского трафика по сети вообще. Этот промежуток времени недоступности сети для пользователей называется временем сходимости (или конвергенции).

В состоянии Learning интерфейс все еще не пересылает пользовательский трафик, но принимает его через интерфейс и строит на его основе новую таблицу MAC-адресов. Время нахождения в каждом из этих состояний определяется таймером ForwardDelay.

Соответственно, по умолчанию время сходимости STP при изменении в физической конфигурации сети составляет 50 секунд (20 секунд на то, чтобы заметить неисправность и по 15 секунд на каждый переходный этап). По сравнению с ремонтом, например, кабельной линии это незначительное время, что дает преимущество в использовании топологий с избыточностью, но при текущих требованиях к доступности сетей - это время может оказаться критичным. Поэтому для более быстрой сходимости был разработан стандарт IEEE 802.1w протокола RSTP.
Протокол RSTP

Принят как стандарт IEEE 802.1w в 2001 году. Общие идеи такие же, как и для STP. Так же и по тем же критериям выбирается корневой коммутатор, так же коммутаторы обмениваются сообщениями BPDU Hello, так же блокируются некоторые порты. Только в протоколе RSTP статус заблокированных портов называется discarding, а не blocking.

В протоколе RSTP существенно уменьшена скорость конвергенции (сходимости) сети за счет появления дополнительных типов портов, alternate port - является заранее выбранным запасным портом для корневого порта коммутатора, т.е. того, через который коммутатор быстрее всего достигает корневого коммутатора. Backup port так же заранее выбран для быстрой замены отказавшего порта для нижерасположенных коммутаторов. Эти решения позволили убрать стадию Listening. Все вместе существенно сократило время конвергенции сети, поэтому использование RSTP более предпочтительно.

Протокол RSTP может работать в сетях совместно с протоколом STP.
#################### Настройка STP на OpenvSwitch ####################

На большинстве современных коммутаторов (если не на всех) протокол STP включен по умолчанию. На некоторых коммутаторах это протокол STP (IEEE 802.1D), на других - протокол RSTP (IEEE 802.1w). Тем не менее, настройки по умолчанию не всегда являются оптимальными. Часто необходимо настроить STP самостоятельно для получения нужного результата. В виртуальных коммутаторах, таких как OpenVSwitch, протокол STP необходимо включать отдельно.

Во всех командах в примерах используется br0, в реальных конфигурациях для настройки нужно указывать тот бридж, который реально задействован в вашем коммутаторе, тот, в котором находятся нужные вам интерфейсы. Для включения протокола STP в OpenVSwitch используется команда:

ovs-vsctl set Bridge br0 stp_enable=true
ovs-vsctl set bridge br0 stp_enable=true

Для выключения используется команда ovs-vsctl set Bridge br0 stp_enable=false

Для того, чтобы корнем дерева стал заранее выбранный производительный коммутатор (а при его отказе другой выбранный тоже заранее), необходимо на этих коммутаторах задать приоритет для STP. В OpenVSwitch приоритет задается командой:

ovs-vsctl set Bridge br0 other_config:stp-priority=0x7000

Как вы видите, этой командой задается пониженный приоритет (по умолчанию 0x8000), для того, чтобы данный коммутатор выиграл выборы корневого коммутатора.

Для более точного определения, по каким путям будет проходить пользовательский трафик в результате построения связующего дерева, можно задавать стоимость интерфейса, отличающуюся от стандартной. Стоимость задается командой:

ovs-vsctl set Port eth0 other_config:stp-path-cost=10

Таймеры по умолчанию можно изменить:

    изменение таймера MaxAge (по умолчанию 20 сек)

ovs-vsctl set Bridge br0 other_config:stp-max-age=10 

-изменение таймера ForwardDelay (по умолчанию 15 сек)

ovs-vsctl set Bridge br0 other_config:stp-forward-delay=10

Таймеры достаточно устанавливать только на корневом и запасном корневом коммутаторах.

Текущие настройки коммутатора можно посмотреть с помощью команды:

ovs-vsctl list bridge

Посмотреть статус портов можно с помощью команды:

ovs-ofctl show br0

Пример настройки STP на OVS

Для примера настройки возьмем простую сеть, изображенную на рисунке 4. У нас есть три коммутатора: Core I, Core II и Edge. Нам нужно, чтобы коммутаторы Core I и Core II обменивались между собой, а коммутатор Edge в нормальном состоянии передавал данные через коммутатор Core I, а в случае пропадания связи с коммутатором Core I - переключался на передачу данных через коммутатор Core II. А при восстановлении соединения, возвращался обратно на Core I. Для реализации данной схемы необходимо, чтобы Core I был корневым коммутатором, Core II - резервным корневым коммутатором, а Edge не становился корневым коммутатором ни при каких обстоятельствах. Для этого мы поставим приоритет на Core I - 0x6000, на Core II - 0x7000, а на Edge оставим приоритет по умолчанию. Создадим на всех трех коммутаторах Bridge br0 и добавим в него оба сетевых интерфейса (как создавать бридж и добавлять в него интерфейсы мы рассматривали ранее в практикуме).

Включим STP на коммутаторе Core I и сразу же установим на нем приоритет.

ovs-vsctl set Bridge br0 stp_enable=true

ovs-vsctl set Bridge br0 other_config:stp-priority=0x6000

Далее включим STP на коммутаторе Core II и тоже сразу же установим на нем приоритет.

ovs-vsctl set Bridge br0 stp_enable=true

ovs-vsctl set Bridge br0 other_config:stp-priority=0x7000

Наконец, включим STP на коммутаторе Edge.

ovs-vsctl set Bridge br0 stp_enable=true

Теперь зададим стоимость одного из исходящих интерфейсов на коммутаторе Edge. Задавая большое значение стоимости порта мы определяем преимущественный путь трафика через другой порт коммутатора Edge.

ovs-vsctl set Port eth3 other_config:stp-path-cost=150

Посмотрим, как применились все настройки с помощью команды:

ovs-vsctl list bridge

Посмотреть статус портов можно с помощью команды:

ovs-ofctl show br0

Нам осталось проверить работоспособность сети с помощью команды ping.
Настройка RSTP на OVS

Протокол RSTP настраивается аналогично, но с небольшими изменениями. Для включения протокола RSTP в OpenVSwitch используется команда:

ovs-vsctl set Bridge br0 rstp_enable=true

(Для выключения протокола RSTP в OpenVSwitch используется команда ovs-vsctl set Bridge br0 rstp_enable=false)

Приоритет коммутатора в RSTP задается в десятичном виде. Поэтому внимательно нужно проверять, чтобы задаваемое значение делилось нацело на 4096:

ovs-vsctl set Bridge br0 other_config:rstp-priority=28672

Таймеры по умолчанию можно изменить командами:

ovs-vsctl set Bridge br0 other_config:rstp-max-age=10

ovs-vsctl set Bridge br0 other_config:rstp-forward-delay=10

Стоимость пути через интерфейс определяется командой:

ovs-vsctl set Port eth0 other_config:rstp-path-cost=150

Пример настройки RSTP на OVS

Для примера настройки возьмем ту же самую простую топологию сети, изображенную на рисунке 4. У нас есть три коммутатора: Core I, Core II и Edge. Задача аналогичная предыдущей. Нужно, чтобы коммутаторы Core I и Core II обменивались между собой, а коммутатор Edge в нормальном состоянии передавал данные через коммутатор Core I, а в случае пропадания связи с коммутатором Core I - переключался на передачу данных через коммутатор Core II. А при восстановлении соединения, возвращался обратно на Core I. Bridge на всех коммутаторах уже созданы, интерфейсы в них добавлены.

Включаем RSTP на коммутаторе Core I и сразу же установим на нем приоритет. (Проверяем, чтобы десятичное значение приоритета было кратным 4096)

ovs-vsctl set Bridge br0 rstp_enable=true
ovs-vsctl set Bridge br0 other_config:rstp-priority=24576

Далее включим RSTP на коммутаторе Core II и тоже сразу же установим на нем приоритет. (Также проверяем, чтобы десятичное значение приоритета было кратным 4096)

ovs-vsctl set Bridge br0 rstp_enable=true
ovs-vsctl set Bridge br0 other_config:rstp-priority=28672

Наконец, включим RSTP на коммутаторе Edge.

ovs-vsctl set Bridge br0 rstp_enable=true

Теперь зададим стоимость одного из исходящих интерфейсов на коммутаторе Edge.
Задавая большое значение стоимости порта мы определяем преимущественный путь трафика через другой порт коммутатора Edge.
ovs-vsctl set Port eth0 other_config:rstp-path-cost=150






