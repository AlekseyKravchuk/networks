# Физические параметры сетевого интерфейса, такие как скорость и дуплекс, настраиваются с помощью утилиты ethtool (входит в состав пакета ethtool).
# Устанавливаем пакет 'ethtool'
sudo apt-get install ethtool

#Установка пакета 'net-tools':
sudo apt-get install net-tools

# Посмотреть список сетевых интерфейсов можно с помощью команды ifconfig из пакета net-tools,
# либо с помощью команд 'ip address' или 'ip link' из более современного пакета iproute2
ip address  ## или сокращенно: ip a

# Если интерфейс находится в состоянии DOWN, перевести его в состояние UP можно разными способами, например:
# => с помощью команды ip link:
sudo ip link set <interface_name> up

# => с помощью команды ifconfig:
sudo ifconfig <interface_name> up

# Для настройки физических параметров сетевого адаптера используется команда ethtool <имя адаптера> с разными ключами.
# Посмотреть текущие параметры можно с помощью команды:
ethtool <interface_name>

ethtool enx0c5b8f279a64  # пример команды с именем реального интерфейса

# Иногда встречаются ситуации, когда при неудачном автосогласовании может установиться, например, полудуплексный режим.
# Этот режим катастрофически снижает реальную скорость и производительность сети, поэтому важно, чтобы дуплекс всегда был полным.
# Пересогласование параметров можно инициировать командой:
sudo ethtool -r <interface_name>  # пересогласование параметров

ethtool -r enx0c5b8f279a64  # пример команды с именем реального интерфейса

# Для проверки сетевой связности между двумя устройствами в подавляющем большинстве случаев используется утилита ping из пакета iputils-ping, установка которого выполняется командой:
sudo apt-get install iputils-ping

# Среди вывода команры "ethtool" есть очень интересный параметр - "Supports Wake-on: pumbg" - с его помощью можно удаленно включить машину
kav@vak:~$ sudo ethtool enp37s0
Settings for enp37s0:
	Supported ports: [ TP	 MII ]
	Supported link modes:   10baseT/Half 10baseT/Full
	                        100baseT/Half 100baseT/Full
	                        1000baseT/Full
	Supported pause frame use: Symmetric Receive-only
	Supports auto-negotiation: Yes
	Supported FEC modes: Not reported
	Advertised link modes:  10baseT/Half 10baseT/Full
	                        100baseT/Half 100baseT/Full
	                        1000baseT/Full
	Advertised pause frame use: Symmetric Receive-only
	Advertised auto-negotiation: Yes
	Advertised FEC modes: Not reported
	Speed: Unknown!
	Duplex: Unknown! (255)
	Auto-negotiation: on
	master-slave cfg: preferred slave
	master-slave status: unknown
	Port: Twisted Pair
	PHYAD: 0
	Transceiver: external
	MDI-X: Unknown
	Supports Wake-on: pumbg
	Wake-on: d
	Link detected: no

# поменять MAC-адрес на сетевом интерфейсе
sudo ip link set dev eth0 down                  # предварительно временно выключаем интерфейс
ip link set dev eth0 address 1a:2b:3c:4d:5e:6f
sudo ip link set dev eth0 up                    # снова включаем интерфейс

# Наиболее распространенные утилиты из пакета iproute2:
# Утилита ip позволяет нама получать информацию о параметрах интерфейсов L2, L3 и менять их настройки

# Утилита tc (от traffic control) - позволяет нам просматривать конфигурацию управления трафиком

# Утилита ss (аналог netstat) - позволяет просматривать текущие соединения и открытые порты на нашем устройстве.

# Если на устройстве присутствует много интерфейсов, то можно ограничить вывод информации одним интерфейсом:
ip link show dev enx0c5b8f279a64

# Выключить необходимый интерфейс:
ip link set enx0c5b8f279a64 down

# ВКЛЮЧИТЬ необходимый интерфейс:
ip link set enx0c5b8f279a64 up

# ==================================
Networks by Rebrain: Основы IP адресации
https://www.youtube.com/watch?v=-MEXqJLZVg4&t=4s


Любые 2 устройства могут взаимодействовать друг с другом только в том случае, если их ip-адреса из одного диапазона.
Для логической идентификации устройства и определения принадлежности его к конкретной сети нужен ip-адрес.

ip-адрес - это уникальное число, которое используется для логической идентификации устройства в сети.    
ip_address = сетевая_часть_адреса(net_id) + узловая_часть_адреса(host_id)
ip_address = net_id + host_id

Задача: даны 3 ip-адреса: 190.100.5.115, 190.100.6.113, 190.101.0.1
Требуется определить, находятся ли эти адреса в одном диапазоне (в одной подсети) или нет?

Чтобы ответить на этот вопрос нужно четко знать, где проходит граница между сетевой и хостовой(узловой) частями адреса (между net_id и host_id).

Класс A: /8
Класс B: /16
Класс C: /24

Маска подсети позволяет установить границу между сетевой и хостовой частью адреса.
Маска - это такое же 32-битное число (шаблон), в котором в левой его части записываются единицы (они указывают на СЕТЕВУЮ часть адреса),
а в правой его части - нули (они указывают на УЗЛОВУЮ часть адреса).
Единицы в маске указывают на сетевую часть адреса; нули в маске указывают на хостовую (узловую) часть адреса.

При наложении AND-маски на ip-адрес выделяется сетевая часть.
Когда требуется выделить сетевую часть адреса, используется побитовое наложение маски на ip-адрес с помощью поразрядной операции "И" (&).
net_ip = ip & mask

Результатом наложения маски сети на ip-адрес является также число, которое называется адресом сети или сетевым адресом.
Хостовая (узловая) часть сетевого адреса заполнена нулями.

Маску сети можно записать в виде префикса: /1, /2, ..., /8, .../16, /17, ..., /24, ..., /30, /31, /32.
Префикс - это количество единиц в маске.

Задача 1: найти адрес сети для ip-адреса 192.168.1.73/26
  11000000.10101000.00000001.01|001001
& 11111111.11111111.11111111.11|00000
  11000000.10101000.00000001.01|00000
  192.168.1.64  - net_ip
  192.168.1.192 - mask
  
Задача 2: Проверить принадлежность ip-адресов одной сети:
192.168.1.43/26 и 192.168.1.67/26
11000000.10101000.00000001.00|101011 192.168.1.43/26
11000000.10101000.00000001.01|000011  192.168.1.67/26

Задача 3: Какие адреса являются корректными адресами сети?
Корректным адресом сети является такой адрес, у которого в хостовой части все разряды заполнены нулями.
192.23.41.0/24  11000000.00010111.00101001.|00000000  // все разряды в хостовой части заполнены нулями => это корректный адрес сети
1.1.15.0/21     00000001.00000001.00001|111.00000000  // в хостовой части первые три бита - единицы => это НЕ корректный адрес сети
127.0.0.32/27   01111111.00000000.00000000.001|00000  // корректный адрес сети
  
# ================= Broadcast (широковещательный) адрес =================
broadcast-адрес - это ещё один служебный адрес, т.е. его нельзя назначать устройствам сети.
broadcast-адрес используется для отправки пакетов всем узлам сети.
По определению broadcast-адрес - это адрес, у которого хостовая часть заполнена всеми единицами.

Пусть имеется адрес сети (network ip-address): 190.100.0.0/16
10111110.01100100.|00000000.00000000
11111111.11111111.|00000000.00000000 mask

Нужно найти широковещательный адрес.
11111111.11111111.00000000.00000000 mask
  00000000.00000000.|11111111.11111111 ~mask
| 10111110.01100100.|00000000.00000000 network_ip
  10111110.01100100.|11111111.11111111 broadcast_ip (190.100.255.255)

broadcast_ip = ip | ~mask
~mask ещё называют wildcard-маска

Задача 5. Что из перечисленного ниже является адресом широковещательной рассылки в сети класса B с маской подсети по умолчанию?
Подсказка: Класс B: net.net.host.host: 10xxxxxx.X.X.X (128-191.X.X.X.X)
172.16.10.255    10101100.00010000.|00001010.11111111  # НЕТ
172.16.255.255   10101100.00010000.|11111111.11111111  # ДА
172.255.255.255  10101100.11111111.|11111111.11111111  # ДА
255.255.255.255  11111111.11111111.|11111111.11111111  # НЕТ

Задача 5.2
Рассчитать broadcast-адрес для ip-адреса 192.168.1.73/26
11000000.10101000.00000001.01|001001 ip_addr
11111111.11111111.11111111.11|000000 mask
00000000.00000000.00000000.00|111111 ~mask

   11000000.10101000.00000001.01|001001 ip_addr
|  00000000.00000000.00000000.00|111111 ~mask
   11000000.10101000.00000001.01|111111 broadcast_ip (bin)
   192.168.1.127 broadcast_ip (dec)
   
# Расчет диапазона адресов устройств (unicast-адресов)
Для назначения ip-адресов можно назначать весь диапазон адресов, кроме net_ip и broadcast_ip.
Потому что любой unicast-адрес в хостовой части представляет собой некоторую комбинацию из нулей и единиц.
Кроме комбинации со всеми нулями (это будет служебный адрес сети, net_ip).
Кроме комбинации со всеми единицами (это будет служебный широковещательный адрес, broadcast_ip)

В заданном диапазоне ПЕРВЫМ доступным ip-адресом будет:    first_ip_in_range = net_ip + 1
В заданном диапазоне ПОСЛЕДНИМ доступным ip-адресом будет: last_ip_in_range  = broadcast_ip - 1

Пример. Для адреса 192.168.1.73/26 net_ip = ip & mask.
  11000000.10101000.00000001.01|001001 ip
& 11111111.11111111.11111111.11|000000 mask
  11000000.10101000.00000001.01|000000 net_ip (bin)
  192.168.1.64                         net_ip (dec)
  
first_ip_in_range = net_ip + 1 = 192.168.1.64 + 1 = 192.168.1.65
last_ip_in_range  = broadcast_ip - 1 = 192.168.1.127 - 1 = 192.168.1.126
Т.о. устройствам можно назначать ip-адреса из следующего диапазона: [192.168.1.65; 192.168.1.126]

Задача 6. Сгенерировать конфигурацию для dhcpd-сервера
subnet 172.16.8.0 netmask 255.255.252.0 {
        authoritative;
	option domain-name-servers 8.8.4.4, 8.8.8.8;
	option routers 172.16.8.1;
	oprion subnet-mask 255.255.252.0;
}

# --------> пишем функцию для перевода ip-адреса из строки в точечно-десятичном формате в целое число
ip_str = '192.168.1.2'
octs = [int(x) for x in ip_str.split('.')]  # octs = [192, 168, 1, 2]

octs[0] = 192 = 00000000 00000000 00000000 11000000
octs[1] = 168 = 00000000 00000000 00000000 10101000
octs[2] = 1   = 00000000 00000000 00000000 00000001
octs[3] = 2   = 00000000 00000000 00000000 00000010
Теперь октеты нужно сконкатенировать таким образом, чтобы получилось одно число:
bin:    192      168      1        2
dec: 11000000 10101000 00000001 00000010

octs[0] << 24: 11000000 00000000 00000000 00000000 : 192  0   0   0 
octs[1] << 16: 00000000 10101000 00000000 00000000 : 0   168  0   0
octs[2] << 8 : 00000000 00000000 00000001 00000000 : 0    0   1   0
octs[3]      : 00000000 00000000 00000000 00000010 : 0    0   0   2
concatenated : 11000000 10101000 00000001 00000010 : 11000000101010000000000100000010

Итого, результирующий ip-адрес (как число): octs[0] << 24 | octs[1] << 16 | octs[2] << 8 | octs[0]

# --------> Обратная задача: пишем функцию для перевода ip-адреса  в точечно-десятичном формате в число (int)
Есть исходный ip-адрес = 3232235778 (192.168.1.2)
11000000.10101000.00000001.00000010
11000000.10101000.00000001.00000010 >> 24 = 0000000.0000000.00000000.11000000

11000000.10101000.00000001.00000010 >> 16 = 0000000.0000000.11000000.10101000
   0000000.0000000.11000000.10101000
&  0000000.0000000.00000000.11111111
(11000000.10101000.00000001.00000010 >> 16) & 255

11000000.10101000.00000001.00000010 >> 8 = 00000000.11000000.10101000.00000001
   00000000.11000000.10101000.00000001
&  00000000.00000000.00000000.11111111
(11000000.10101000.00000001.00000010 >> 8) & 255

11000000.10101000.00000001.00000010
   11000000.10101000.00000001.00000010
&  00000000.00000000.00000000.11111111
(11000000.10101000.00000001.00000010) & 255

# --------> Вычисляем broadcast
По определению broadcast-адрес - это адрес, у которого хостовая часть заполнена всеми единицами.
ip = 3232235778 (192.168.1.2/24) = 11000000.10101000.00000001.00000010
mask = 255.255.255.0             = 11111111.11111111.11111111.00000000
net_ip = ip & mask = 192.168.1.0 = 11000000.10101000.00000001.00000000

broadcast_ip = ip | ~mask       =    11000000.10101000.00000001.00000010
	       	    		   & 00000000.00000000.00000000.11111111
К сожалению, в Python операция побитового отрицания работает не так, как в С++, то нужно использовать искусственный прием.
Как же вычислить ~mask в Python?
вот наша маска: 11111111.11111111.11111111.00000000 (255.255.255.0)
нужно получить: 00000000.00000000.00000000.11111111 (0  .  0.  0.255)

Какая побитовая операция позволит это сделать?

11111111.11111111.11111111.00000000
XOR(^)
11111111.11111111.11111111.11111111  (0xFFFFFFFF)


Задача 7: Сколько хостов можно разместить в сети 190.100.0.0/21?
Количество хостов, которые поместятся в сети равно количеству уникальных комбинаций, которые можно составить из хостовой порции данного ip-адреса за вычетом
двух запрещенных комбинаций - со всеми нулями (net_ip) и со всеми единицами (broadcast_ip).
N = 2**n - 2 // где n - это количество бит в узловой части адреса
32 - 21 = 11 бит в в узловой части адреса
N = 2**11 - 2 = 2046

Задача 8: В сети нужно разместить 256 устройств. Какую маску выбрать?
Т.е. сколько нужно иметь бит в хостовой части адреса, чтобы составить заданное значение уникальных комбинаций.
Т.о. нужно найти ближайшую степень двойки, при возведении в которую получится число, большее или равное требуемому количеству устройств + 2 (net_ip и broadcast_ip ).
32 - (log2(N+2) -> ∞)

В Python:
math.log(256 + 2, 2) = 8.011227255423254; 
32 - math.ceil(math.log(256 + 2, 2)) = 23 бита => маска должна быть /23

# ===================== Специальные IPv4-адреса =====================
Интерфейс обратной петли (loopback): 127.0.0.1 (127.0.0.0 - 127.255.255.255 - зарезервированы)
Локальный адрес канала: 169.254.0.0 - 169.254.255.255 (169.254.0.0/16) - служба APIPA
Адреса TEST-NET: 192.0.2.0 - 192.0.2.255 (192.0.2.0/24) - для образовательных и обучающих целей
Экспериментальные адреса: 240.0.0.0 - 255.255.255.254
Мультикаст-адреса (адреса групповой рассылки): 224.0.0.0 - 239.255.255.255

# ===================== Частные IPv4-адреса =====================
Кроме специальных ip-адресов существуют адреса, которые никогда ни при каких обстоятельствах не маршрутизируются в сети Интернет и не могут использоваться для адресации устройств в Интернете.
Их называют частными (private) адресами. Эти адреса используются исключительно для адресации внутри изолированных частных локальных корпоративных сетей.
       Диапазон		         Маска      Количество узлов
10.0.0.0 - 10.255.255.255.255	  /8             ~16.5 млн.
172.16.0.0 - 172.32.255.255       /16            ~65.5 тыс.
192.168.0.0 - 192.168.255.255     /24             254

# ===================== ИТОГИ  =====================
net_ip = ip & mask
broadcast_ip = ip | ~mask
1st_ip = net_ip + 1
last_ip = broadcast_ip - 1


# ===================== РАЗБИЕНИЕ СЕТЕЙ НА ПОДСЕТИ  =====================
https://www.youtube.com/watch?v=SOZXLPvsFsQ&list=PL_jzYoo7u8dGpqTl6quYwZ_EFzmN75BXE&index=7

Процедура разделения сети на подсети:
Базовый адрес сети: 192.168.1.0/24 - это общее адресное пространство, которое мы будем делить на подсети.
Базовый адрес сети нам нужно разбить на 2 поддиапазона и сделать это таким образом, чтобы:
1) они не пересекались между собой,
2) но чтобы они были частью общего адресного пространства 192.168.1.0/24

Чтобы выполнялось условие 2) нужно, чтобы все адреса и в одной, и в другой подсети начинались на 192.168.1. ...
Общая часть <192.168.1> всегда должна оставаться неизменной, сколько бы мы ни делали подсетей в рамках одной сети.

Итак, для создания двух подсетей выделяют 1 бит из узловой части базового адреса и переносят его в сетевую часть.
Для первой подсети значение этого (перенесенного из сетевой части) бита выставляют в 0, в для второй подсети этот бит высталяют в 1:
1-ая подсеть: 192.168.1.0|0000000;
2-ая подсеть: 192.168.1.1|0000000;
                       ^ ^
		       | |
В результате граница между сетевой и хостовой порцией сдвигается на 1 бит вправо.
Что будет с новой маской, которая получится у каждой подсети?
Маска станет /25.

Что будет с хостовой порцией в каждой из 2-х новых подсетей?
Она станет на 1 бит меньше, т.е. 7 бит  => в каждой из организованных подсетей поместится 2**7 - 2 = 128 - 2 = 126 сетевых устройств.

В итоге мы получили 2 подсети с маской /25 (255.255.255.128). И обе они являются частью общего адресного пространства 192.168.1

Сетевой адрес для 1-ой подсети: 192.168.1.0|0000000 = 192.168.1.0/25
Сетевой адрес для 2-ой подсети: 192.168.1.1|0000000 = 192.168.1.128/25

Теперь для каждой из двух подсетей можно посчитать по известным формулам:
- broadcast_ip
- 1st_ip
- last_ip

#################### 1-ая подсеть ####################
Сетевой адрес (net_ip) для 1-ой подсети: 192.168.1.0|0000000 = 192.168.1.0/25

маска /25 = 255.255.255.128 =             1111111111111111111111111|0000000

broadcast_ip = 192.168.1.0/25 | ~mask =   11000000.10101000.00000001.0|0000000 - сетевой адрес для 1-ой подсети
	       		      	        | 00000000.00000000.00000000.0|1111111 - ~mask
					  11000000.10101000.00000001.0|1111111 = 192.168.1.127

1st_ip = net_ip + 1 = 192.168.1.0/25 + 1 = 192.168.1.1
last_ip = broadcast_ip - 1 = 192.168.1.126

#################### 2-ая подсеть ####################
Сетевой адрес (net_ip) для 2-ой подсети: 192.168.1.1|0000000 = 192.168.1.128/25

маска /25 = 255.255.255.128 =             1111111111111111111111111|0000000

broadcast_ip = 192.168.1.1/25 | ~mask =   11000000.10101000.00000001.1|0000000 - сетевой адрес для 2-ой подсети
	       		      	        | 00000000.00000000.00000000.0|1111111 - ~mask
					  11000000.10101000.00000001.1|1111111 = 192.168.1.255

1st_ip = net_ip + 1 = 192.168.1.128/25 + 1 = 192.168.1.129
last_ip = broadcast_ip - 1 = 192.168.1.255 - 1 = 192.168.1.254

# ===================== РАЗБИЕНИЕ СЕТИ НА 4 ПОДСЕТИ  =====================
Адрес сети - это адрес, у которого в хостовой порции ВСЕ нули.

Пусть базовый адрес сети (net_ip) = 192.168.1.0/24
Тогда общая маска для 4-х подсетей = 192.168.1.11|000000 = 192.168.1.192
Подсеть 1: 192.168.1.00|000000/26 = 192.168.1.0/26
	   broadcast_ip = 192.168.1.63
	   1st_ip = subnet_ip + 1 = 192.168.1.0 + 1 = 192.168.1.1
	   last_ip = broadcast_ip - 1 = 192.168.1.63 - 1 = 192.168.1.62
	   
Подсеть 2: 192.168.1.01|000000/26 = 192.168.1.0.64/26
	   broadcast_ip = 192.168.1.127
	   1st_ip = subnet_ip + 1 = 192.168.1.64 + 1 = 192.168.1.65
	   last_ip = broadcast_ip - 1 = 192.168.1.127 - 1 = 192.168.1.126

Подсеть 3: 192.168.1.10|000000/26 = 192.168.1.128/26
	   broadcast_ip = 192.168.1.191
	   1st_ip = subnet_ip + 1 = 192.168.1.128 + 1 = 192.168.1.129
	   last_ip = broadcast_ip - 1 = 192.168.1.191 - 1 = 192.168.1.190

Подсеть 4: 192.168.1.11|000000/26 = 192.168.1.192/26
	   broadcast_ip = 192.168.1.255
	   1st_ip = subnet_ip + 1 = 192.168.1.192 + 1 = 192.168.1.193
	   last_ip = broadcast_ip - 1 = 192.168.1.255 - 1 = 192.168.1.254

Итог: при выделении из хостовой порции адреса 2-х бит мы можем организовать из одной базовой сети /24 ровно 4 подсети /26.

# ===================== РАСЧЕТ КОЛИЧЕСТВА ПОДСЕТЕЙ  =====================
Nподсетей = 2^k, где k - количество бит, выделенных из узловой части адреса
Например, для создания 3-х подсетей нам потребуется забрать 3 бита из хостовой порции 2^3 = 8

Расчет количества бит, которые необходимо выделить из узловой части базового адреса для создания нужного количества подсетей.
from math import log2
from math import ceil
N = 8          # N - количество подсетей, которые необходимо создать
ceil(log2(N))  # количество бит, необходимое для организации N штук подсетей

# ############################## ЗАДАЧА на разбиение сети на подсети ####################
По какому принципу и по какому алгоритму вы будете делить сеть на подсети, как вы будете это делать?
Дан некоторый базовый адрес сети (общее адресное пространство): 172.16.8.0/22.
Указанное общее адресное пространство (базовый адрес сети) нужно разбить на N-ное количество подсетей и для каждой такой подсети вычислить:
	  - адрес подсети;
	  - broadcast_ip;
	  - 1st_ip;
	  - last_ip;
	  - диапазон IP-адресов, которые можно назначать клиентам.
 
Сгенерировать конфигурационные файлы dhcpd-сервера для этих 10 подсетей.
Соответственно, для каждой из подсетей нужно сгенерировать свой файлик test0.net, test1.net, ..., test9.net, в котором будет некоторое следующее содержимое:
test0.net (в каждом таком файлике описывается своя подсеть):

subnet 172.16.8.0 netmask 255.255.255.192 {
       authoritative;
       option domain-name-servers 8.8.4.4, 8.8.8.8;
       option routers 172.16.8.1;
       option subnet-mask 255.255.255.192;
}

pool { allow members of "users" "cl-floor0-0"; deny dynamic bootp clients; range 172.16.8.2; }
pool { allow members of "users" "cl-floor0-1"; deny dynamic bootp clients; range 172.16.8.3; }
pool { allow members of "users" "cl-floor0-2"; deny dynamic bootp clients; range 172.16.8.4; }
...
pool { allow members of "users" "cl-floor0-N"; deny dynamic bootp clients; range 172.16.8.62; }

##################################################	 
для организации N=2 подсетей нам нужно перекинуть 1 бит из хостовой в новую сетевую часть адреса
подсети: 0, 1
число N=2 в бинарном представлении = 0b10
==> 0b10 - 1 = 0b01 (одна единица в получившемся числе -> нужно перебросить 1 бит)
##################################################

для организации N=4 подсетей нам нужно перекинуть 2 бита из хостовой в новую сетевую часть адреса
подсети: 00, 01, 10, 11
число N=4 в бинарном представлении = 0b100
==> 0b100 - 1 = 0b011 (2 единицы в получившемся числе -> нужно перебросить 2 бита)
##################################################
для организации N=8 подсетей нам нужно перекинуть 3 бита из хостовой в новую сетевую часть адреса
подсети: 000, 001, 010, 011, 100, 101, 110, 111
число N=8 в бинарном представлении = 0b1000
==> 0b1000 - 1 = 0b0111 (3 единицы в получившемся числе -> нужно перебросить 3 бита)
##################################################
для организации N=16 подсетей нам нужно перекинуть 4 бита из хостовой в новую сетевую часть адреса
подсети: 0000, 0001, 0010, 0011, 0100, 0101, 0110, 0111, 1000, 1001, 1010, 1011, 1100, 1101, 1110, 1111
число N=16 в бинарном представлении = 0b10000
==> 0b10000 - 1 = 0b01111 (4 единицы в получившемся числе -> нужно перебросить 4 бита)

Если количество подсетей, которые требуется создать, соответствует степени двойки, то с помощью такого нехитрого расчета:
N_digits = N - 1   # количество единиц, которые нужно перебросить из хостовой порции адреса в новую сетевую порцию.
Всё бы ничего, если бы у нас количество требуемых подсетей всегда было равно какой-то степени двойки.

Но нам нужно организовать 10 подсетей + нужно написать универсальный скрипт.
N = 10 = 0b1010; 0b1010 - 1 = 0b1001 = 9 - такой способ не подходит.
Но мы однозначно знаем позицию первого установленного бита в числе: pos_leftmost_bit = 3 (zero-based).
Теперь, если мы добьем все позиции справа от pos_leftmost_bit единицами, то получим количество N_digits.

N = 10 подсетей
####################
10 = 0...1010
0...1010 >> 1 = 0...0101 (5)
0...1010 (10)
|
0...0101 (5)
=
0...1111 (N стало равно 15)
####################n
0...1111 >> 2 = 0...0011 (3)
0...1111 (15)
|
0...0011 (3)
=
0...1111 (15)
####################
0...1111 >> 4 = 0...0000 (0)
0...1111
|
0...000
=
0...1111
####################
0...1111 >> 8 = 0...0000 (0)
0...1111
|
0...0000
=
0...1111
####################
0...1111 >> 16 = 0...0000 (0)
0...1111
|
0...0000
=
0...1111

#################### Маски переменной длины (VLSM, Variable Length Subnet Masks) ####################
==> Networks by Rebrain Основы IP адресации 2
		     Рассмотрение типичной топологии сети с использованием VLSM: 2:00:22 / 2:09:31    	     		
		     https://www.youtube.com/watch?v=SOZXLPvsFsQ&list=PL_jzYoo7u8dGpqTl6quYwZ_EFzmN75BXE&index=9

Разделение базового адресного пространства (базового сетевого адреса) на подсети разного размера, исходя из количества хостов в каждой подсети.


# ===================== Настройка IP-адреса =====================
Существует 2 основных способа назначения IP-адреса: статически (вручную) и динамически (автоматически по протоколу DHCP от DHCP-сервера).
В консоли Linux Ubuntu 20.04 настроить или изменить ip адрес можно несколькими способами. Основные из них:
    - Способ 1 — с помощью команд ip a (ip addr), ifconfig, и др (позволяет изменить и сохранить настройки вплоть до момента рестарта системы);
    - Способ 2 — с помощью конфигурационного файла /etc/network/interfaces;
    - Способ 3 — с помощью утилиты Netplan.

# ===================== Способ 1 — Настройка параметров интерфейса с помощью ifconfig / ip a =====================
# Выполненные настройки хранятся в оперативной памяти, следовательно сбросятся после перезагрузки системы.
# Чтобы изменения сохранились перманентно, первый вариант - их нужно описать в конфигурационном файле /etc/network/interfaces.

ifconfig <имя интерфейса> <ip адрес> netmask <маска в точечно-десятичном формате>
# Пример:
ifconfig eth0 192.168.1.1 netmask 255.255.255.0
# ИЛИ
ifconfig ens160 192.168.30.21 netmask 255.255.255.0 broadcast 192.168.30.255 up

# Те же настройки можно назначить командой ip address (alias: ip a)
ip address {add|change|replace} <ip_адрес>/<маска в виде префикса> dev <имя интерфейса>
ip address add 192.168.30.21/24 dev ens160
ip address add 192.168.1.1/24 dev eth0

# ===================== Способ 2 — Изменение параметров конфигурации интерфейсов через /etc/network/interfaces =====================
user@rebraime-vm:~$ sudo nano /etc/network/interfaces

# определим конфигурацию сетевых интерфейсов:
auto lo ens160

# Loopback interface
iface lo inet loopback

# Interface ens160 configuration
iface ens160 inet static
  address 192.168.30.21
  netmask 255.255.255.0
  gateway 192.168.30.254
  dns-nameservers 8.8.8.8 8.8.4.4

Параметры созданной конфигурации:
    auto — говорит операционной системе, что интерфейс нужно активировать и настраивать при запуске;
    iface ens160 inet static — выбирает из всех интерфейсов указанный и определяет тип настройки — статический;
    address — ip адрес интерфейса;
    netmask — маска;
    gateway — шлюз по умолчанию;
    dns-nameservers — определяет IP-адреса DNS-серверов, которые будут использоваться для преобразования доменных имен в IP-адреса.

Минимальные настройки на интерфейсе включают только ip адрес и маску.
Для применения настроек достаточно либо перезапустить сервис networking (sudo /etc/init.d/networking restart или sudo systemctl restart networking) либо перезагрузить систему.

# ===================== Способ 3 — Настройка с помощью утилиты netplan.io =====================
# Одним из популярных способов конфигурации параметров сетевых интерфейсов в операционной системе Linux является использование утилиты netplan.io,
# где в формате YAML можно описать параметры всех сетевых адаптеров.

# Начиная с версии Ubuntu 18.04 LTS, Netplan входит в базовый образ системы по умолчанию и используется как основной инструмент настройки сетевых параметров.
# Иначе для установки утилиты необходимо выполнить команду:
user@rebrainme-vm:~$ sudo apt install netplan.io

# Так как netplan - это только утилита для настройки параметров, ей нужны службы операционной системы, которые данные настройки смогут применить.
# В терминах netplan такие службы называют renderer (рендеры). На данный момент это NetworkManager или NetworkD (Ubuntu Manpages: systemd-networkd.service).

# Файлы конфигурации, в которых описываются параметры сетевых адаптеров, расположены в директории: /etc/netplan/.
# Найдем конфигурационный файл и определим параметры сетевых интерфейсов.

# По умолчанию утилита netplan создает конфигурационный файл /etc/netplan/01-network-manager-all.yaml, допишем в него параметры интерфейсов,
# используя текстовый редактор emacs:
sudo emacs /etc/netplan/01-network-manager-all.yaml

# Изначально содержимое файла выглядит так:

# Let NetworkManager manage all devices on this system
network:
  version: 2
  renderer: NetworkManager

где

    network — блок, из которого будут браться параметры настройки интерфейсов;
    version — версия YAML для описания параметров;
    renderer — системная служба, которая будет обрабатывать и применять настройки.

# Допишем в файл параметры сетевых интерфейсов:
# Let NetworkManager manage all devices on this system
network:
  version: 2
  renderer: NetworkManager
  ethernets:
    ens160:
      dhcp4: false
      addresses:
        - 192.168.30.21/24
      nameservers:
        addresses:
          - 8.8.8.8
      routes:
        - to: default
          via: 192.168.30.254
    lo:
      renderer: networkd
      match:
        name: lo
      addresses:
        - 192.168.20.1/24

Описание структуры:

    настройки IP-адресов проводных интерфейсов указываются в ethernets (для VLAN, WiFi и прочего предназначены другие имена);
    способ настройки адресов (динамический или статический) определяется сопоставлением: dhcp4: true/false;
    в addresses определяется список IP-адресов, присвоенных интерфейсу (список указывается либо в [], либо с переходом на новую строку и использованием -);
    в nameservers указываются IP-адреса DNS-серверов;
    routes используется для добавления маршрутов, мы указали маршрут по умолчанию как 0.0.0.0/0 (все сети, default) и через (to) указали адрес маршрутизатора.

Для проверки синтаксиса и конфигурации используется команда sudo netplan try. Если в конфигурации допущены ошибки, вывод команды сообщит об этом. Для примения конфигурации используется команда sudo netplan apply.

Более подробную информацию о возможностях утилиты netplan.io можно получить по ссылке: Netplan — The network configuration abstraction renderer (https://netplan.io/)

############################## Установить сетевой адрес для устройства ##############################
ip a add 10.10.10.101/24 dev eth0

#sh mac address-table dynamic

Задание:

Дано: Сеть топологии "звезда", построенная на базе неуправляемых коммутаторов и состоящая из центрального коммутатора, к которому подключены еще 5 коммутаторов, к ним, в свою очередь, подключены 9 ПК.
При этом номер порта на центральном коммутаторе соответствует номеру коммутатора, подключенному к нему.
На ПК назначены IP адреса из подсети 192.168.1.0/24, при этом номер последнего октета равен номеру ПК, например 192.168.1.8 у ПК-8.
Но кое где совершены ошибки и недоработки, например, не подключен кабель, выключен интерфейс, и т.д. Исправьте их, и убедитесь, что есть связность между всеми хостами.

ip a add 192.168.1.1/24 dev eth0
ip a add 192.168.1.2/24 dev eth0
ip a add 192.168.1.3/24 dev eth0
ip a add 192.168.1.4/24 dev eth0
ip a add 192.168.1.5/24 dev eth0
ip a add 192.168.1.6/24 dev eth0
ip a add 192.168.1.7/24 dev eth0
ip a add 192.168.1.8/24 dev eth0

ip link set eth0 up

ip address del 192.168.1.2 dev eth0
ip address add 192.168.1.2 dev eth0

ip address del 192.168.136.114/24 dev enp6s0

# For setting an IP address, use it like this:
ip addr add [ip_address] dev [interface]
ip a add 192.168.1.1/24 dev eth0

# Выключить необходимый интерфейс:
ip link set eth0 down

# ВКЛЮЧИТЬ необходимый интерфейс:
ip link set eth0 up

ip link set eth0 down
ip address del 192.168.1.3/16 dev eth0

############################## NET 05: Логическая коммутация. Интерфейс в режиме моста ##############################
Программный коммутатор называется бридж (bridge), он умеет так же как обычный коммутатор пересылать кадры с одного своего порта на другой (порты могу быть как физические так и виртуальные),
связывая подключенные к нему машины - как физические, так и виртуальные, или контейнеры, при этом работая на программном уровне внутри обычной линукс-машины.
Именно по этой причине мы называем его не физическим, а логическим.

Под понятием "логическая коммутация" подразумевается внедрение в работу логических (программных) коммутаторов.
В ядре Linux есть встроенный программный (логический) L2-bridge. Его администрирование осуществляется утилитой brctl из пакета 'bridge-utils'.

Linux-бридж может комбинировать в себе две роли: роль коммутатора и брандмауэра (межсетевого экрана).
Комбинация коммутатора и брандмауэра выполняется с помощью инструмента ebtables (Ethernet bridge frame table administration).
Утилита ebtables используется для создания правил, которые анализируют и фильтруют Ethernet кадры. По сути это брандмауэр на канальном уровне.

Основные возможности ebtables:
    - фильтрация на уровне протокола Ethernet
    - фильтрация MAC-адресов
    - трансляция MAC-адресов (NAT)
    - ведение логов
    - счетчики кадров
    - возможность добавлять, удалять, вставлять правила, сбрасывать цепочки, обнулять счетчики

# Установка bridge-utils:
sudo apt-get install bridge-utils

# Проверяем, что утилита brctl установлена и работает:
brctl show

# Создаем бридж с именем rbr-br-01 и проверим командной brctl show, что бридж создался:
brctl addbr rbr-br-01
brctl show

# Добавляем интерфейсы eth1-eth3 в созданный bridge:
brctl addif rbr-br-01 eth1
brctl addif rbr-br-01 eth2
brctl addif rbr-br-01 eth3

# По умолчанию созданный бридж интерфейс в неактивном состоянии!
# Поэтому необходимо поднять интерфейс rbr-br-01 на машине rbr-br-node и проверить, что он в состоянии 'UP':
ip link set rbr-br-01 up   # или ifconfig rbr-br-01 up
ip address

# Просмотреть таблицу MAC-адресов созданного бриджа:
brctl showmacs rbr-br-01

# Анализ содержимого вывода команды 'brctl showmacs rbr-br-01' (анализ таблицы MAC-адресов):
Если в столбце is local стоит yes напротив MAC-адреса, это значит, что MAC-адрес относится к собственному интерфейсу непосредственно на Linux Bridge,
а если значение "no" - эти MAC-адреса принадлежат устройствам, которые подключаются к Linux Bridge с другой стороны (физические или виртуальные машины или контейнеры).
Под "ageing timer" (время жизни) понимается время в секундах, которое MAC-адрес будет находиться в CAM-таблице (forwarding database) бриджа с момента получения последнего
пришедшего кадра с этим адресом на порт.
В обычной жизни вам редко понадобится менять данные параметры, но при необходимости это можно сделать командой brctl setageing <brname> <time> (время указывается в секундах).


##################################################

apt update && apt-get install bridge-utils  # Установите bridge-utils на машине BR-TEST-01.
brctl addbr br-test-01                      # Добавьте с помощью утилиты brctl новый бридж на машину BR-TEST-01 с именем br-test-01.
brctl show                                  # Проверяем, что бридж создался

# Добавляем порты eth1-eth4 в созданный бридж 'br-test-01'.
brctl addif br-test-01 eth1
brctl addif br-test-01 eth2
brctl addif br-test-01 eth3
brctl addif br-test-01 eth4

# Проверяем, что в бридж добавлены все 4 порта.
brctl show

# По умолчанию созданный бридж интерфейс в неактивном состоянии!
# Поэтому необходимо поднять интерфейс rbr-br-01 на машине rbr-br-node и проверить, что он в состоянии 'UP':
ip link set br-test-01 up

# или с помощью ifconfig:
ifconfig br-test-01 up

# Просмотреть таблицу MAC-адресов созданного бриджа:
brctl showmacs br-test-01

# Добавляем время жизни MAC-адресов, равным 120 секунд, и проверяем, отключив любой хост, что MAC-адрес этого хоста исчез из таблицы. 
# brctl setageing <brname> <time> (время указывается в секундах).
brctl setageing rbr-br-01 12

############################## NET 06: Коммутация в виртуальной среде. Openv Switch ##############################
Виртуальный коммутатор OpenvSwitch (OVS)  используется как компонент архитектуры во многих платформах виртуализации.
Цель: разобраться, какие реализации виртуальных коммутаторов используются для коммутации, например, между виртуальными машинами или между контейнерами, как их настраивать.

############################## Основные компоненты OpenvSwitch: ##############################
    1) ovs-vswitchd — это демон, реализующий коммутатор вместе с сопутствующим модулем ядра Linux;
    2) ovsdb-server — облегченная база данных, которую ovs-vswitchd запрашивает для получения своей конфигурации;
    3) ovs-dpctl — инструмент для настройки модуля ядра для коммутатора;
    4) ovs-vsctl — утилита для запроса и обновления конфигурации ovs-vswitchd;
    5) ovs-appctl — утилита, которая отправляет команды для запуска демонов OpenvSwitch;
    6) ovs-vdocker — инструмент для управления связностью контейнеров Docker.

############################## Основные КОМАНДЫ OpenvSwitch: ##############################
    1) ovs-vsctl - этот инструмент используется для настройки и просмотра следующих операций на OVS:
       - конфигурация портов;
       - добавление/удаление bridge;
       - связывание и тегирование VLAN.
       
         Примеры команды:
       ovs-vsctl add-br br-name-1       # Эта команда создаст интерфейс в режиме моста (bridge) в БД коммутатора с именем "br-name-1"
       ovs-vsctl list bridge br-name-1  # Эта команда выведет подробную таблицу с параметрами бриджа "br-name-1"
       
    2) ovs-ofctl - инструмент cmd для администрирования и мониторинга коммутаторов OpenFlow.
         Примеры команды:
       ovs-ofctl dump-ports-desc br-name-1  # Выведет статистику портов бриджа с именем "br-name-1"
       
    3) ovs-dpctl - отображает потоки c пакетами, которые фактически прошли через систему в течение последних нескольких секунд.
    4) ovs-appctl - утилита для управления демонами (сервисами) Open vSwitch. Используется для настройки параметров модуля журнала, а также для просмотра потоков OpenFlow.
         Примеры команды:
      ovs-appctl bridge/dump-flows br-100   # Выводит потоки OpenFlow, включая скрытые. Полезная команда для устранения неполадок.
      ovs-appctl vlog/list                  # Перечисляет известные модули журнала и их уровни логирования.

############################## Настройка OVS на примере построения коммутации в контейнерах Docker c одним хостом: ##############################
########## Open vSwitch c одним бриджем и двумя контейнерами ##########
"container_1" (eth0: 172.25.0.2/24) <===> "container_2" (eth0: 172.25.0.3/24)
	    	   		      |
				      |
				  Open vSwitch
			====== "docker-ovsbr1" =====
			              |
				      |
			  eth0: 192.168.100.1/24

# Установка OpenvSwitch:
# Предварительно необходимо обновить список пакетов в системе:
sudo apt-get update

# Устанавливаем OpenvSwitch:
sudo apt-get install -y openvswitch-switch

# В составе пакета openvswitch присутствует ovs-docker (/usr/bin/ovs-docker)


# # Устанавливаем Docker. Минимальная установка docker для нашей конфигурации выглядит следующим образом:
sudo apt-get install -y docker.io
The following packages have unmet dependencies:
 containerd.io : Conflicts: containerd
E: Error, pkgProblemResolver::Resolve generated breaks, this may be caused by held packages.

# Переустановка docker: (причина - containerd.io conflicts containerd)
sudo apt-get remove containerd.io && sudo apt-get autoremove
sudo apt install docker.io docker-compose -y
systemctl start docker

#  Команда 'gpasswd' назначает пользователя в группу с некоторыми критериями безопасности (используется для администрирования /etc/group и /etc/gshadow).
# Adding user $USER  to group 'docker'
sudo gpasswd -a $USER docker

# Также нам потребуется загрузить образ ubuntu из официального репозитория Docker Hub, на основе которого будут созданы будущие контейнеры:
sudo docker pull ubuntu

# Если образ успешно загружен, его можно увидеть в списке с помощью команды "sudo docker images" или "sudo docker image ls":
sudo docker images
sudo docker image ls

# #################### Создание бриджа OVS: ####################
# Здесь мы добавим новый бридж OVS с именем "docker-ovsbr1" для подключения контейнеров в сети 172.25.0.0/24:
# ip =      172.25.0.0
# netmask = 255.255.255.0
# net_ip =  172.25.0.0
# bcast_ip = 172.25.0.255
# first_ip = 172.25.0.1
# last_ip =  172.25.0.254

# Создать новый бридж Open vSwitch (OVS) с именем "docker-ovsbr1" для подключения контейнеров в сети 172.25.0.0/24:
sudo ovs-vsctl add-br docker-ovsbr1

# Для работы с командой "ifconfig" устанавливаем пакет "net-tools":
sudo apt-get install net-tools

# С помощью команды ifconfig присваиваем ip-адрес и маску из отдельной сети 172.25.0.0/24, а также переводим созданный интерфейс в состояние UP:
sudo ifconfig docker-ovsbr1 172.25.0.1 netmask 255.255.255.0 up

# Проверим, создался ли новый бридж "docker-ovsbr1":
sudo ovs-vsctl show
kav@bqp:~$ sudo ovs-vsctl show
91f87741-de07-4c42-b1c1-8aad5caf52ae
    Bridge docker-ovsbr1   # <== Бридж был успешно 
        Port docker-ovsbr1
            Interface docker-ovsbr1
                type: internal
    ovs_version: "2.17.9"

############################## Запуск и настройка контейнера ##############################
1.1. Запустим 2 контейнера с именами "container1" и "container2" Ubuntu Docker:
sudo docker run -it --name container1 -d ubuntu /bin/bash
sudo docker run -it --name container2 -d ubuntu /bin/bash

1.2. Посмотрим, что получилось
# -a Show all containers (default shows just running)
docker ps -a
kav@bqp:~$ docker ps -a
CONTAINER ID   IMAGE          COMMAND       CREATED          STATUS                     PORTS     NAMES
403b0de902ae   ubuntu         "/bin/bash"   38 seconds ago   Up 38 seconds                        container2
470153715eb5   ubuntu         "/bin/bash"   44 seconds ago   Up 43 seconds                        container1
5aa7ea3cff8f   3db8720ecbf5   "bash"        2 weeks ago      Exited (127) 2 weeks ago             dreamy_gauss
475a24a10b72   hello-world    "/hello"      2 weeks ago      Exited (0) 2 weeks ago               sweet_joliot
0e241e00c21d   hello-world    "/hello"      2 weeks ago      Exited (0) 2 weeks ago               kind_perlman

# Вывести информацию ТОЛЬКО о ЗАПУЩЕННЫХ (running) контейнерах:
docker ps

1.3. Останавливаем контейнеры:
docker container stop container1
docker container stop container2

1.4. Проверяем вывод ifconfig с остановленными контейнерами (вывод представлен в сокращенном виде):
kav@bqp:~$ ifconfig
docker0: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500
docker-ovsbr1: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
enp42s0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
enp4s0: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500
lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
virbr0: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500

1.5. Запускаем уже существующие контейнеры:
sudo docker container start container1
sudo docker container start container2

1.6. Снова проверяем вывод 'ifconfig' - теперь вывод дополнился 2-мя новыми интерфейсами:
veth5eef7af: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
vetha867122: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500

# Docker создал виртуальные интерфейсы veth[UNIQUE_ID]
# Нужно выяснить, к каким контейнерам относятся новые появившиеся виртуальные интерфейсы:
# https://stackoverflow.com/questions/37860936/find-out-which-network-interface-belongs-to-docker-container
docker exec -it container1 cat /sys/class/net/eth0/iflink

kav@bqp:~$ docker exec -it container1 cat /sys/class/net/eth0/iflink
17

# После этого выясняем соответствие:
ip address | grep 17:
17: veth5eef7af@if16: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue master docker0 state UP group default 

2. Соединим эти контейнеры с бриджем OpenvSwitch (OVS) с именем "docker-ovsbr1" через интерфейсы контейнеров "eth1", присвоим им адреса 
sudo ovs-docker add-port docker-ovsbr1 eth1 container1 --ipaddress=172.25.0.2/24
sudo ovs-docker add-port docker-ovsbr1 eth1 container2 --ipaddress=172.25.0.3/24

3. Посмотрим, что у нас получилось:
sudo ovs-vsctl show

kav@bqp:~/bash_scripts$ sudo ovs-vsctl show
91f87741-de07-4c42-b1c1-8aad5caf52ae
    Bridge docker-ovsbr1
        Port bf0d39c02c894_l
            Interface bf0d39c02c894_l
        Port b1e440b2884d4_l
            Interface b1e440b2884d4_l
        Port docker-ovsbr1
            Interface docker-ovsbr1
                type: internal
    ovs_version: "2.17.9"

4. Определим IP-адреса контейнеров:
sudo docker exec container1 ifconfig eth1

# Указанная команда может отсутствовать внутри контейнера - чтобы решить эту проблему нужно внутри контейнера выполнить установку необходимых пакетов командой:
sudo docker exec container1 bash -c 'apt update -qq && apt install -y iputils-ping net-tools'
sudo docker exec container2 bash -c 'apt update -qq && apt install -y iputils-ping net-tools'

5. Пробуем выполнить пинг-запрос с container1 (172.25.0.2) на container2 (172.25.0.3):
sudo docker exec container1 ping 172.25.0.3

# Как видим пинг до container2 через бридж docker-ovsbr1 успешно проходит:
kav@bqp:~/bash_scripts$ sudo docker exec container1 ping 172.25.0.3
PING 172.25.0.3 (172.25.0.3) 56(84) bytes of data.
64 bytes from 172.25.0.3: icmp_seq=1 ttl=64 time=0.300 ms
64 bytes from 172.25.0.3: icmp_seq=2 ttl=64 time=0.067 ms
64 bytes from 172.25.0.3: icmp_seq=3 ttl=64 time=0.059 ms

# Почему-то после перезапуска ПК OVS перестал видеть порты
kav@bqp:~/networks$ sudo ovs-vsctl show
91f87741-de07-4c42-b1c1-8aad5caf52ae
    Bridge docker-ovsbr1
        Port bf0d39c02c894_l
            Interface bf0d39c02c894_l
                error: "could not open network device bf0d39c02c894_l (No such device)"
        Port b1e440b2884d4_l
            Interface b1e440b2884d4_l
                error: "could not open network device b1e440b2884d4_l (No such device)"
        Port docker-ovsbr1
            Interface docker-ovsbr1
                type: internal
    ovs_version: "2.17.9"

# Чтобы починить, удалим их:
sudo ovs-vsctl del-port bf0d39c02c894_l
sudo ovs-vsctl del-port b1e440b2884d4_l

kav@bqp:~/networks$ sudo ovs-vsctl show
91f87741-de07-4c42-b1c1-8aad5caf52ae
    Bridge docker-ovsbr1
        Port docker-ovsbr1
            Interface docker-ovsbr1
                type: internal
    ovs_version: "2.17.9"

# Повторим сделанное ранее:
sudo ovs-docker add-port docker-ovsbr1 eth1 container1 --ipaddress=172.25.0.2/24
sudo ovs-docker add-port docker-ovsbr1 eth1 container2 --ipaddress=172.25.0.3/24

А теперь усложним наш пример.
Представьте, что нам поставили задачу добавить еще два контейнера, но с отдельной сетью 172.35.0.0/24,
при этом сделать так, чтобы контейнеры из одной сети могли общаться с контейнерами из другой.

#################### Схема D. Open vSwitch c двумя бриджами и четырьмя контейнерами ####################
1. Итак, первое, что нам нужно сделать — добавить бридж в уже работающий Open vSwitch c названием docker-ovsbr2 и назначить ему ip-адрес 172.35.0.1 с маской 255.255.255.0:
sudo ovs-vsctl add-br docker-ovsbr2
sudo ifconfig docker-ovsbr2 172.35.0.1 netmask 255.255.255.0 up

2. Проверяем добавленный бридж docker-ovsbr2 и назначенный ему ip-адрес:
sudo ovs-vsctl show | grep docker-ovsbr2
kav@bqp:~/networks$ sudo ovs-vsctl show | grep docker-ovsbr2
    Bridge docker-ovsbr2
        Port docker-ovsbr2
            Interface docker-ovsbr2

ifconfig -a | grep -A2 docker-ovsbrw



3. Далее, как и в первой задаче нам нужно запустить два контейнера, но c названиями container3 и container4, и присвоить им ip-адреса из той же сети, в которой расположен новый бридж docker-ovsbr2:
docker run -it --name container3 -d ubuntu /bin/bash
docker run -it --name container4 -d ubuntu /bin/bash
sudo ovs-docker add-port docker-ovsbr2 eth1 container3 --ipaddress=172.35.0.2/24
sudo ovs-docker add-port docker-ovsbr2 eth1 container4 --ipaddress=172.35.0.3/24

4. Также проверяем, что порты добавились в бридж docker-ovsbr2:
sudo ovs-vsctl show

5. На любом контейнере, подключенном через бридж docker-ovsbr2 (пусть это будет container3 с ip-адресом 172.35.0.2), проверим интерфейс eth1 и попробуем отправить пинг-запрос до контейнера, подключенного к docker-ovsbr1 (например на container1 с ip-адресом 172.25.0.2):
# Проверяем на container3 настройки интерфейса eth1 командой ifconfig:n
sudo docker exec container3 ifconfig eth1

# Осталось попробовать отправить пинг-запрос до container1 с ip-адресом 172.25.0.2:
sudo docker exec container3 ping 172.25.0.2

6. На последнем шаге давайте попробуем отправить пинг запрос контейнеру container4 (172.35.0.3) с container2 (172.25.0.3). Не будем подробно останавливаться на всех шагах, так как они аналогичны предыдущим действиям, просто выполним команду ping:
sudo docker exec container2 ping 172.35.0.3


############################## Команды для диагностики и просмотра конфигурации OpenvSwitch ##############################
1. отобразить список созданных бриджей:
ovs-vsctl list-br

kav@bqp:~/networks$ sudo ovs-vsctl list-br
docker-ovsbr1
docker-ovsbr2

2. отобразить подробный список бриджей и интерфейсов, входящих в них (с этой командой мы работали, поэтому вывод опустим здесь).
ovs-vsctl show

3. отобразить список интерфейсов, входящих в бридж ovs-sys-br (ovs-sys-br — это наименование созданного бриджа здесь в качестве примера):
sudo  ovs-vsctl list-ports docker-ovsbr2

4. выводит в консоль статистику для сетевых устройств, связанных с бриджем (ovs-sys-br — это наименование созданного бриджа здесь в качестве примера):
ovs-ofctl dump-ports ovs-sys-br
########################################

#################### NET 10: Введение в QoS. Политики качества обслуживания трафика в OpenvSwitch ####################

#################### Настройка ограничения скорости входящего трафика в OpenvSwitch ####################
Для реализации QoS существует два стандартных метода маркировки трафика:
    - IEEE 802.1p — маркировка на канальном уровне.
    - DiffServ или ToS — маркировка на сетевом уровне.
В маршрутизаторах и коммутаторах 3-го уровня применяется другой вид приоритизации, при котором в заголовок IP добавляется специальный байт ToS (Type of Service),
в котором указывается информация о приоритете.
Поле ToS состоит из 6 бит DiffServ Code Point (DSCP) и 2 бит Explicit Congestion Notification. DSCP использует 64 значения для уровней сервиса, что позволяет настроить приоритеты очень гибко. 

Политику QoS можно реализовать различными способами, наиболее простой - ограничение пропускной способности для классов трафика.
Существует 2 разных подхода к ограничению скорости:
   - полисинг (Traffic Policing);
   - шейпинг (Traffic Shaping).
Полисинг ограничивает скорость путем отбрасывания лишнего трафика, шейпинг - путем буферизации лишнего трафика.


Утилита iperf - кроссплатформенная консольная клиент-серверная программа — генератор/измеритель TCP и UDP трафика для тестирования пропускной способности и производительности сети.
# Устанавливаем 'iperf' и другие необходимые сетевые пакеты:
sudo docker exec container1 bash -c 'apt update -qq && apt install -y iputils-ping net-tools iproute2 iperf3'
sudo docker exec container2 bash -c 'apt update -qq && apt install -y iputils-ping net-tools iproute2 iperf3'

# для работы с ifconfig из пакета net-tools:
sudo apt-get install net-tools

# для работы с командой 'ip' из пакета iproute2:
sudo apt-get install iproute2

# По умолчанию iperf3 работает так: сервер принимает данные, а клиент отправляет.
# На хосте B (container2) запустим серверную часть:
sudo docker exec container2 bash -c 'iperf3 -s -p 4000 -f K'

# Например, замер скорости по порту 4000 с выводом данных в Кбайтах будет выглядеть так:
sudo iperf3 -s -p 4000 -f K
-----------------------------------------------------------
Server listening on 4000
-----------------------------------------------------------

Ключи 'iperf3' только для серверной части:
    -D, --daemon - запустить сервер в фоновом режиме;
    -I, --pidfile - путь для записи PID файла процесса;
    -1, --one-off - обработать только одно подключение клиента, а затем выйти.


# На хосте A запускаем клиентскую часть, которая будет отправлять данные серверу на хосте B:
sudo docker exec container1 bash -c 'iperf3 -c 173.16.1.3 -p 4000 -t 2 -P 2'

Ключи клиентской части:
    --sctp - использовать SCTP вместо TCP, по умолчанию тестирование проводится по TCP;
    -u, --udp - использовать UDP вместо TCP;
    --connect-timeout - таймаут для первого соединения с сервером в миллисекундах;
    -b, --bitrate - битрейт, для UDP используется по умолчанию 1 Мбит/сек, для TCP не ограничено;
    -t, --time - время одного теста в секундах, по умолчанию 10 секунд;
    -R, --reverse - обратный тест, не клиент отправляет данные серверу, а сервер клиенту;
    -P - количество потоков;
    -w - размер окна TCP;
    -4, --version4 - использовать только IPv4;
    -6, --version6 - использовать только IPv6.


Общие ключи программы 'iperf3':
    -p, --port - указать порт для сервера или к какому порту надо подключаться, по умолчанию он работает на порту 5201;
    -f, --format - формат выводимых данных, доступны значения: k(Кбит), K(Кбайт), m(Мбит), M(Мбайт), g(Гбит),G (Гбайт);
    -i, --interval - интервал времени между выводами результата тестирования;
    -F, --file - использовать данные из файла вместо генерации случайных данных;
    -V, --verbose - вывод максимально подробной информации;
    -J, --json - вывод в формате JSON;
    --logfile - записывать информацию в лог файл;
    --forceflush - очищать историю вывода перед выводом следующего результата тестирования;
    -v, --version - версия программы.

# Например, замер скорости с ip-адреса серверной части B 192.168.0.14 по порту 4000 за интервал времени 2 секунды на 2х потоках:
sudo iperf3 -c 192.168.0.14 -p 4000 -t 2 -P 2
Connecting to host 192.168.0.14, port 4000
Reverse mode, remote host 192.168.0.14 is sending
[  4] local 192.168.0.13 port 62817 connected to 192.168.0.14 port 4000
[  6] local 192.168.0.13 port 62818 connected to 192.168.0.14 port 4000
[ ID] Interval           Transfer     Bandwidth
[  4]   0.00-1.00   sec  3.96 MBytes  33.3 Mbits/sec
[  6]   0.00-1.00   sec  3.75 MBytes  31.5 Mbits/sec
[SUM]   0.00-1.00   sec  7.71 MBytes  64.7 Mbits/sec
- - - - - - - - - - - - - - - - - - - - - - - - -
[  4]   1.00-2.00   sec  3.79 MBytes  31.8 Mbits/sec
[  6]   1.00-2.00   sec  3.64 MBytes  30.5 Mbits/sec
[SUM]   1.00-2.00   sec  7.43 MBytes  62.3 Mbits/sec
- - - - - - - - - - - - - - - - - - - - - - - - -
[ ID] Interval           Transfer     Bandwidth
[  4]   0.00-2.00   sec  7.88 MBytes  33.0 Mbits/sec                  sender
[  4]   0.00-2.00   sec  7.75 MBytes  32.5 Mbits/sec                  receiver
[  6]   0.00-2.00   sec  7.62 MBytes  32.0 Mbits/sec                  sender
[  6]   0.00-2.00   sec  7.62 MBytes  32.0 Mbits/sec                  receiver
[SUM]   0.00-2.00   sec  15.5 MBytes  65.0 Mbits/sec                  sender
[SUM]   0.00-2.00   sec  15.4 MBytes  64.5 Mbits/sec                  receiver

iperf Done.

Результаты замера отображаются как на клиентской части хоста A, так и на серверной - хост B.

sudo docker exec container1 ping 173.16.1.3

# Просмотреть только ЗАПУЩЕННЫЕ контейнеры (Listing Running Containers):
docker ps

# Просмотреть только ВСЕ контейнеры (Listing All Containers, including the stopped ones):
docker ps -a

#
sudo ovs-vsctl show

# настроим политику QoS простым полисингом - ограничим скорость входящего трафика на интерфейсе 7c47675a7f924_l (результат вывода 'sudo ovs-vsctil show').
# В OvS полисингом регулируется только входящий трафик. В консоли OvS вводим:
sudo ovs-vsctl set Interface 7c47675a7f924_l ingress_policing_rate=1000000
sudo ovs-vsctl set Interface 7c47675a7f924_l ingress_policing_burst=1000000

# ingress_policing_rate=1000000 здесь устанавливается максимальная скорость входящего трафика (в Кбит/с);
# ingress_policing_burst=1000000 максимальный объем данных (в килобитах), который этот интерфейс может принять сверх установленной скорости.

# То же самое, но для интерфейса '5a6faad49b8b4_l'
sudo ovs-vsctl set Interface 5a6faad49b8b4_l ingress_policing_rate=1000000
sudo ovs-vsctl set Interface 5a6faad49b8b4_l ingress_policing_burst=1000000

# Способ простой, но может плохо взаимодействовать с некоторыми сетевыми протоколами и выдавать неожиданные результаты.
# Рекомендуется устанавливать policing_rate и policing_burst одинаковой величины, необходимо тестировать работу после настройки. 


############################## NET 11: Виртуальные локальные сети VLAN ##############################
IEEE 802.1Q — открытый стандарт, который описывает процедуру тегирования трафика для передачи информации о принадлежности к VLAN по сетям стандарта IEEE 802.3 Ethernet. 

Устройства в одном VLAN изолированы от устройств в другом, а пакеты между сетями VLAN могут передаваться только через устройство 3-го уровня.
Каждый VLAN имеет свой идентификатор или номер (VLAN ID) - число в диапазоне от 1 до 4094.
Всего на коммутаторах может быть до 4096 VLAN, но при этом создать возможно от 2 до 4094, т.к. VLAN 1 зарезервирован как default VLAN и всегда изначально уже присутствует на коммутаторе,
а 0 и 4095 зарезервированы под специальные нужды и не могут быть созданы.

Суть процесса разделения физической сети на виртуальные (VLAN-ы) состоит в маркировке кадров, передающихся в сети, определяющей принадлежность каждого кадра определенному VLAN ID
за счет добавления специального тега в его заголовок. Размер данного тега равен 4 байта или 32 бита.

#################### Режимы работы портов коммутатора ####################
Существует 2 основных режима работы портов коммутатора с поддержкой VLAN:
    - режим доступа (или access или нетегированный);
    - режим транк (или trunk или dot1q или тегированный).

По тегу коммутатор определяет, к какому VLAN принадлежит кадр.
Если на порту настроена передача нескольких VLAN, такие порты называются trunk портами (тегированными) и используются для магистральных соединений между коммутаторами или другим сетевыми устройствами
с поддержкой 802.1q.

Если же к порту подключено пользовательское конечное устройство, то как правило, ему передается трафик только одного VLAN, и такие порты называются access портами (нетегированными).
К слову, если к trunk порту подключить пользовательское устройство, которое не поддерживает 802.1q, то оно будет принимать только трафик из Native VLAN (также его называют PVID), т. к. он передается без тега.

Основное отличие в работе двух режимов состоит в следующем.
При отправке кадра с ИСХОДЯЩЕГО порта (если порт является членом данного VLAN):
    - если порт в режиме "ACCESS" (нетегированный), то коммутатор удаляет VLAN тег из заголовка фрейма;
    - сохраняет тег, если порт в режиме trunk (тегированный)

При приеме ВХОДЯЩЕГО кадра на порт в режиме "ACCESS" коммутатор маркирует кадр (который изначально пришел без тега от конечного устройства), тегом с VLAN ID, настроенным на этом порту.

Логика такой работы в том, что конечные устройства (ПК, сетевые принтеры, и т.д.), в основном, не имеют поддержки 802.1q (в этом и нет необходимости),
поэтому ПРИ ОТПРАВКЕ кадра на такое устройство свитч должен отправить кадр без тега в чистом виде.

И наоборот, при приеме входящего изначально нетегированного кадра от одного из таких устройств на порт необходимо вставить внутрь заголовка кадра тег с определенным VLAN ID, чтобы пометить кадр от конечного устройства нужным номером VLAN.

Дальше этот кадр будет передаваться уже промаркированным VLAN тегом и только на те порты, через которые разрешено пропускать кадры с этим VLAN ID (они могут быть также либо в режиме access в этом VLAN, либо в режиме trunk, в котором разрешена передача маркированных кадров в нескольких VLAN).

 В результате конечные хосты не имеют представления, в каком VLAN-е они находятся, потому что всю работу по маркировке/размаркировке кадров выполняет свитч, и кадр от конечного устройства на свитч поступит еще без тега, а обратно к конечному устройству от свитча - уже без тега.

Еще стоит отметить, что на access портах может быть тегированный трафик и более одного VLAN, в случае если это Voice VLAN, все дело в том, что VoIP телефоны имеют внутри маленький коммутатор, состоящий из двух портов, который тегированный трафик передает телефону, а нетегированный дальше, подключенному к нему ПК. По умолчанию все порты любого коммутатора находятся в режиме доступа (access) в VLAN 1.

############################################################# Ольга Яновская #############################################################
############################## Настройка VLAN на коммутаторе (D-Link DGS-3000-10TC Gigabit Ethernet Switch) ##############################
1. Создать VLAN на устройстве.
2. Настроить режим портов.
3. Настроить принадлежность портов к VLAN в режиме "access".
4. Пробросить необходимые VLAN через "trunk"-порты (настроить передачу определенных нужных нам тегов через trunk'овые порты).
###########################################################################################

Считается хорошей практикой отделить сеть управления и VLAN-управления от всех других VLAN-ов, которые используются в сети.
Каждой виртуальной локальной сети (VLAN) необходимо поставить в соответствие свою отдельную сеть, т.е. каждая VLAN должна иметь свой диапазон (непересекающийся с другими) адресов.

!!! В режиме "access" можно настроить принадлежность только к одному VLAN_ID !!!

1. Настраиваем коммутатор D-Link, к которому подключены конечные пользователи из двух VLAN'ов + один VLAN для управления сетью (management):
   - VLAN 10: VLAN управления (management) с сетью 10.0.10.0/24 
   - VLAN 20: пользовательский VLAN (User) с сетью 10.0.20.0/24
   - VLAN 30: гостевой VLAN (guest)        с сетью 10.0.30.0/24
   
1.1. Порты #1, #2 в сторону подключения клиентских устройств (из 20-го VLAN'а) мы должны настроить в режиме "access" ("untagged") и установить принадлежность этих портов к VLAN_20.
1.2. Порт #8 в сторону подключения клиентских гостевых устройств (из 30-го VLAN'а) мы должны также настроить в режиме "access" ("untagged") и установить принадлежность этого порта к VLAN_30.
1.3. Магистральный порт #10 D-Link'а подключен к маршрутизатору нужно настроить в режиме "trunk" и разрешить пропуск тегированного трафика для VLAN_10, VLAN_20, VLAN_30.
Если, например, забыть разрешить пропускать через trunk-овый порт трафик с тегом VLAN_20, то пользователи из 20-го VLAN'а не смогут связаться с пользователями из этого же VLAN,
но разделенных trunk-овым портом.
1.4. Также нужно назначить IP-адрес управления на коммутаторе из сети управления, 10.0.10.0/24 - management VLAN.
1.5. Указать, что management-интерфейс будет находиться в VLAN10.

dlink:admin#

# Смотрим, какие VLAN'ы нам доступны из коробки:
show vlan

# По умолчанию все порты на любом коммутаторе находятся в VLAN_1 в нетегированном (untagged) режиме, т.е. по умолчанию разрешено коммутировать кадры с любого порта на любой порт.
# С точки зрения безопасности нужно всех пользователей удалять из дефолтного первого VLAN'а.

# создаем VLAN управления (management VLAN) с VLAN_ID=10 и с именем vMNG:
create vlan vMNG tag 10

# создаем пользовательский VLAN (user VLAN) с VLAN_ID=20 и с именем vUSER:
create vlan vUSER tag 20

# создаем гостевой VLAN (guest VLAN) с VLAN_ID=30 и с именем vUSER:
create vlan vGUEST tag 30

# удаляем все клиентские порты c 1-го по 8-ой из первого VLAN'а
config vlan default delete 1-8

# в 20-ом VLAN'е в нетегированном (access) режиме будут находиться порты 1 и 2.
# настраиваем порты #1, #2 в режиме "access"("untagged") в 20-ый VLAN (user):
config vlanid 20 add untagged 1-2

# настраиваем порт #8 в режиме "access"("untagged") в 30-ый VLAN (guest):
vlan vlanid 30 add untagged 8

# настраиваем порт #10 в режиме "trunk"("tagged") в 10-ый VLAN (management):
vlan vlanid 10 add tagged 10

# разрешаем пропускать через 10-ый магистральный (trunk-овый) порт кадры (frames) тегированные с VLAN_ID = {10, 20, 30}:
config vlan vlanid 10,20,30 add tagged 10

# Настраиваем интерфейс управления на этом D-Link'е. Причем это нужно сделать так, чтобы он сразу же находился в 10-ом VLAN-e.
# Это внутренний логический интерфейс, который будет способен принимать тегированные кадры с VLAN_ID=10.
# Если пришел кадр с тегом VLAN_ID=10, то этот интерфейс примет данный кадр. В противном случае он этот кадр обросит.
create ipif MNG_IF 10.0.10.252/24 vlan_name vMNG

# Команда не отработала (Conflicted subnet addresses). Это значит, что на данном устройстве уже назначен некий интерфейс, у которого IP-адрес пересекается с сетью 10.0.10.0/24.
# Пытаемся разобраться.
show ipif
IP Interface              : System
VLAN Name                 : default
Interface Admin State     : Enabled
DHCPv6 Client State       : Disabled
Link Status               : LinkUp
IPv4 Address              : 10.90.90.90/8 (Manual) Primary
IPv4 State                : Enabled
IPv6 State                : Enabled
DHCP Option12 State       : Disabled
DHCP Option12 Host Name   : 

# Как мы видим, на коммутаторе уже настроен интерфейс управления с IP-адресом 10.90.90.90/8, который принадлежит сети 10.0.0.0/8.
# Диапазон адресав для данной сети: first_ip  = 10.0.0.1
#                                   last_ip   = 10.255.255.254
# Получается, что тот IP-адрес (10.0.10.252/24), который мы пытались присвоить интерфейсу как раз входит в указанный диапазон.

# Чтобы устранить конфликт IP-адресов нам нужно сделать 2 диапазона (сети) 10.0.10.0/24 и 10.0.0.0/8 непересекающимися.
# Изменяем IP-адрес для системного интерфейса:
config ipif System ipaddress 10.90.90.90/24

# Повторно применяем команду
create ipif MNG_IF 10.0.10.252/24 vlan_name vMNG

############################## Настройка VLAN на коммутаторе Cisco L-2+ ##############################

cisco#

# Переходим в режим глобальной конфигурации
conf t

cisco(config)#

cisco(config)# vlan database

# Создаем необходимые VLAN:
cisco(config-vlan)# vlan 10,20,30

cisco(config-vlan)# exit

# Настраиваем магистральные порты "e8" и "g1" в режиме "trunk" и разрешаем передачать через этот trunk-овый канал теги с VLAN_ID={10, 20, 30}
cisco(config)# interface range ethernet e8,g1


# Делаем порты "e8" и "g1" тегированными:
cisco(config-if)# switchport mode trunk

# Говорим, какие теги можно пропускать через trunk-овые порты:
cisco(config-if)# switchport allowed vlan add 10,20,30

# Хотим, чтобы e7-интерфейс использовался специально для админского PC(IP: 10.0.10.10/24), который будет подключаться к порту e7(VLAN_ID=10 (management), в режиме "access")
cisco(config-if)# int ethernet e7
cisco(config-if)# switchport mode access
cisco(config-if)# switchoprt access vlan 10
cisco(config-if)# exit
cisco(config)#

# Осталось настроить интерфейс управления на маршрутизаторе Cisco.
# Только это нужно сделать так, чтобы IP-адрес управления 10.0.10.253/24 был присвоен внутреннему логическому интерфейсу в 10-ом VLAN'e.
cisco(config)# exit
cisco# show vlan

# Возвращаемся в режим глобальной конфигурации:
cisco# conf t

# Создаем внутренний интерфейс управления в нужном нам VLAN'e
cisco(config)# interface vlan 10

# Настраиваем IP-адрес
cisco(config-if)# ip address 10.0.10.253 /24

# Потеряли управление маршрутизатором, поскольку у Cisco поменялся внутренний IP-адрес на интерфейсе управления.
# А конкретно на этой модели существует ограничение, что IP-адрес интерфейса управления может быть только один.
# Раньше этот интерфейс управления находился в дефолтном VLAN'e с VLAN_ID=1 c IP-адресом 192.168.1.254/24.
# Теперь этот интерфейс управления находится в VLAN'e с VLAN_ID=10 и IP-адресом 10.0.10.253 /24

############################## Настройка Microtic'а ##############################
Маршрутизатор Microtic является точкой терминирования 10-го, 20-го и 30-го VLAN-ов.
Дальше Microtic'а тегированный трафик не должен уходить.

На Microtic'e в интерфейс "ether5" входит транковый канал от L-3 коммутатора Cisco.
На этом интерфейсе требуется создать 3 логических интерфейса (сабинтерфейса) в VLAN'ах 10, 20 и 30 и назначить соответствующие им IP-адреса.

# Переходим в меню конфигурации /interface vlan
[root@Mikrotik] > /interface vlan
[root@Mikrotik] /interface vlan> print

# Создаем необходимые саб-интерфейсы:
[root@Mikrotik] /interface vlan> add name=vlan10_mng vlan-id=10 interface=ether5 disabled=no
[root@Mikrotik] /interface vlan> add name=vlan20_user vlan-id=20 interface=ether5 disabled=no
[root@Mikrotik] /interface vlan> add name=vlan30_guest vlan-id=30 interface=ether5 disabled=no

# Осталось навесить IP-адреса на эти саб-интерфейсы:
[root@Mikrotik] /interface vlan> /ip address
[root@Mikrotik] /ip address> add 10.0.10.254/24 interface=vlan10_mng
[root@Mikrotik] /ip address> add 10.0.20.254/24 interface=vlan20_user
[root@Mikrotik] /ip address> add 10.0.30.254/24 interface=vlan30_guest


#################### VLAN в Linux ####################
1) На первом этапе необходимо загрузить модуль ядра 8021q, если он не загружен.
modprobe 8021q
sudo modprobe 8021q

Для этого, ядро должно быть сконфигурировано с поддержкой стандарта IEEE 802.1Q (включается при конфигурировании ядра: в kernel/net/8021q включить 802.1Q VLAN Support или в Network options / 802.1Q VLAN Support). Во многих современных дистрибутивах Linux (Debian, CentOS, openSUSE и т.д) такая поддержка уже включена в ядро.

2) Второй этап - создание логических интерфейсов и назначение им IP-адресов

ip link add link eth0 name eth0.10 type vlan id 10
ip link add link eth0 name eth0.20 type vlan id 20
ip link add link eth0 name eth0.30 type vlan id 30


ip addr add 172.16.10.1/24 dev eth0.10
ip addr add 172.16.20.1/24 dev eth0.20
ip addr add 172.16.30.1/24 dev eth0.30

ip link set eth0.10 up
ip link set eth0.20 up
ip link set eth0.30 up

############################## Настройка VLAN в Open vSwitch (OVS) ##############################
# Добавить новый бридж (программный коммутатор) Open vSwitch с именем ovsbr1
sudo ovs-vsctl add-br ovsbr1

# Присваиваем бриджу с именем "ovsbr1" IP-адрес и маску из отдельной сети 172.25.0.0/24, а также переводим созданный интерфейс в состояние UP:
sudo ifconfig ovsbr1 172.25.0.1 netmask 255.255.255.0 up

# Проверим, создался ли новый бридж "ovsbr1":
sudo ovs-vsctl show

# Синтаксис команды для добавления порта в OVS бридж в режиме access:
ovs-vsctl add-port <bridge_name> <interface_name> tag=<vlan_id>
где: bridge_name - имя OVS бриджа,
     interface_name - имя интерфейса, который будет добавлен в OVS бридж в режиме access с указанным vlan_id.

# Добавляем интерфейс (порт) "eth3" в режиме access в OVS бридж с именем "br0":
ovs-vsctl add-port br0 eth3 tag=10

# Если интерфейс уже находится в OVS бридже, его достаточно перевести в режим access и присвоить соответствующий VLAN-ID командой:
ovs-vsctl set port eth3 tag=10

# Добавление порта в режиме trunk.
# По умолчанию все порты в OVS бридже работают в режиме trunk и пропускают любые тегированные и нетегированные кадры.
# Поэтому любой добавленный интерфейс в OVS бридж будет работать в этом режиме по умолчанию.
# Синтаксис команды для добавления порта в OVS бридж в режиме trunk:
ovs-vsctl add-port <bridge_name> <interface_name>
где: bridge_name - имя OVS бриджа,
     interface_name - имя интерфейса, который будет добавлен в OVS бридж в режиме trunk с пропуском трафика с любыми тегами и без.

# Для указания конкретных VLAN-ID, которые разрешено пропускать через интерфейс в режиме trunk используется ключ trunks. Синтаксис команды:
ovs-vsctl set port <interface_name> trunks=<vlan_id list>
где: interface_name - имя интерфейса, который будет работать в режиме trunk и пропускать тегированный трафик с VLAN-ID, указанными в списке vlan_id list через , или -.

#Например, переведем порт eth2 в режим trunk и разрешим пропуск тегированных кадров c VLAN-ID 10 через него:
ovs-vsctl set port eth2 trunks=10


# Настраиваем access-порты на 
ovs-vsctl set port eth1 tag=201
ovs-vsctl set port eth2 tag=202


############################## Реализация VLAN в сети ##############################
# настраиваем 2 интерфейса в режиме access:
ovs-vsctl set port eth1 tag=201
ovs-vsctl set port eth2 tag=202

# настраиваем trunk-овый порт:
ovs-vsctl set port eth0 trunks=100,201,202

# смотрим, как настроены порты
ovs-vsctl list port eth0

############################## NET 13: Сетевой уровень. Маршрутизация и маршрут по умолчанию. ##############################

#################### Процесс передачи информации между сетями ####################
Перед отправкой данных устройство-отправитель сравнивает результат наложения маски на собственный IP-адрес и IP-адрес получателя.
Здесь возможны 2 варианта:
1) Если получатель находится в той же сети, что отправитель, пакет инкапсулируется в кадр, и в качестве MAC-адреса назначения указывается непосредственно MAC-адрес получателя.
MAC-адрес получателя отправитель выясняет с помощью ARP-процесса.После того, как MAC-адрес получателя, стал известен отправителю, кадр передается ему напрямую;
2) Если получатель находится в другой сети, пакет инкапсулируется в кадр, но в качестве MAC-адреса назначения отправитель указывает MAC-адрес шлюза по умолчанию - маршрутизатора.
MAC-адрес основного шлюза отправитель также определяет с помощью ARP-процесса.

Процесс передачи информации между сетями начинается со второго сценария, и когда пакет отправителя приходит на маршрутизатор для передачи в другую сеть,
дальнейшие действия выполняются в несколько этапов:
1. Маршрутизатор на первом этапе обрабатывает данные на L2 и в частности заголовок пришедшего кадра, а именно:
   - пересчитывает контрольную сумму и сравнивает со значением в поле FCS (Frame Check Sequence - FCS):
     если значение совпадает, значит кадр передан без искажений и не содержит ошибок, иначе кадр уничтожается и дальнейшая обработка не происходит;
   - проверяет MAC-адрес получателя в заголовке канального уровня:
     если там указан MAC-адрес собственного интерфейса, то запускается процесс деинкапсуляции (L2 заголовок и концевик отбрасываются, и из кадра извлекается пакет). В противном случае кадр уничтожается.

2. На втором этапе на маршрутизаторе запускается процесс принятия решения о том, куда пакет передавать дальше, в рамках которого происходит следующее:
   - маршрутизатор ищет в таблице маршрутизации маршрут в сеть назначения, которой принадлежит IP-адрес получателя, и если такой маршрут отстуствует,
     а также отсуствует маршрут по умолчанию - пакет уничтожается и генерируется ICMP сообщение с ошибкой "Destination Unreachable" или "No route to host";
   - если маршрут в сеть назначения в таблице маршрутизации найден, из него извлекается информация об исходящем интерфейсе и IP-адресе следующего по пути следования пакета маршрутизатора.

3. На третьем этапе завершается процесс принятия решения.
   - если в маршрутной информации содержится IP-адрес следующего маршрутизатора, в большинстве случаев это означает, что сеть получателя расположена как минимум через один транзитный роутер,
     и далее запускается ARP-процесс для определения MAC-адреса интерфейса транзитного маршрутизатора для дальнейшей пересылки пакета через него;
   - если в маршрутной информации отсутствует IP-адрес следующего маршрутизатора, в большинстве случаев это означает, что получатель расположен в напрямую подключенной к исходящему интерфейсу
     маршрутизатора сети, и ARP-процесс запускается для определения MAC-адреса устройства-получателя.

4. На финальном этапе IP-пакет инкапсулируется в кадр (с новым заголовком, новыми MAC-адресами отправителя и получателя, а также контрольной суммой) и отправляется через исходящий интерфейс,
   указанный в маршрутной информации.
 
#################### Маршрутизация ####################
МАРШРУТИЗАЦИЯ - это процесс принятия решения о том, как передавать пакет данных для доставки в сеть назначения.
Любой маршрутизатор выполняет 2 основные задачи:
    - Routing (маршрутизация) — поиск маршрута в сеть назначения для IP-пакета;
    - Forwarding (продвижение) — пересылка пакета через нужный исходящий интерфейс.

Путь, соответствующий критериям поиска, называют МАРШРУТОМ.
Решение о том, на какой исходящий интерфейс следует переслать пакет, принимается на основании информации, содержащейся в таблице маршрутизации.

############################## Таблица маршрутизации ##############################
Для просмотра таблицы маршрутизации и работы с ней используются команды route, ip route и netstat -r.

############################## Маршрутизатор на Linux-машине ##############################
Поскольку таблица маршрутизации есть на любом настольном ПК или сервере, при наличии нескольких сетевых интерфейсов он может работать как полноценный маршрутизатор.
Для этого дополнительно необходимо включить передачу пакетов между собственными интерфейсами для пересылки трафика между ними.
Данный параметр в ОС Linux записывается в /proc/sys/net/ipv4/ip_forward. Вывести его значение можно так:
cat /proc/sys/net/ipv4/ip_forward

Значение 0 означает, что передача пакетов между интерфейсами запрещена, то есть маршрутизация отключена.
Чтобы разрешить форвардинг пакетов между интерфейсами, значение необходимо изменить на 1:
echo 1 > /proc/sys/net/ipv4/ip_forward

При изменении параметра net.ipv4.ip_forward с помощью команды echo 1 > /proc/sys/net/ipv4/ip_forward значение сохраняется только до перезагрузки устройства.
Чтобы задать данное значение перманентно, нужно указать его в файле: /etc/systemctl.conf.

Что происходит, когда ПК отправляет пакет в сеть?
Перед тем, как отправить пакет в сеть, ПК определяет, входит ли IP-адрес ПОЛУЧАТЕЛЯ в диапазон доступных адресов сети ОТПРАВИТЕЛЯ.
Почему делаем проверку именно на принадлежность dest-ip к сети ОТПРАВИТЕЛЯ?
В L3-заголовке маски не передаются => диапазон адресов сети ПОЛУЧАТЕЛЯ нашему ПК неизвестен.

Если IP-адрес ПОЛУЧАТЕЛЯ принадлежит диапазону доступных IP-адресов ОТПРАВИТЕЛЯ, то с помощью ARP-протокола ПК-отправитель запрашивает MAC-адрес устройства получателя и начинает с ним взаимодействовать.
Если IP-адрес ПОЛУЧАТЕЛЯ НЕ ВХОДИТ в диапазон доступных IP-адресов ОТПРАВИТЕЛЯ, то ПК-отправитель проверяет свою таблицу маршрутизации на предмет наличия маршрута в сеть получателя.


# Добавляем шлюз по умолчанию:
ip route add default via 10.0.1.1

############################## NET 14: ПО маршрутизации ##############################
Полноценным маршрутизатором можно сделать любой ПК, установив на него специализированное ПО маршрутизации, например Free Range Routing (FRRoutingm, FRR).
FRR обеспечивает реализацию протоколов OSPF, RIP, BGP, IS-IS и многих других.

#################### Установка пакета FRR ####################
Официальный сайт FRR: https://docs.frrouting.org/en/latest/overview.html#how-to-get-frr

Перед началом работы необходимо произвести предварительную настройку самого пакета. Например, необходимо запустить необходимые демоны, т.к. изначально они отключены, сделать это можно, отредактировав файл конфигурации /etc/frr/daemons. В директории /etc/frr/ лежат также и другие конфигурационные файлы, которые нам пригодятся позже. Итак, открыв файл /etc/frr/daemons текстовым редактором, чтобы активировать нужный демон, необходимо напротив его названия в списке изменить no на yes.

# Данная схема очень удобна, так как позволяет запускать только необходимые фичи, особенно если нужно настроить маршрутизацию при ограниченном количестве ресурсов.
# После этого надо сохранить изменения в файле /etc/frr/daemons и перезапустить сервис FRR командой service frr restart.
# Если все сделано верно, то после его перезапуска в выводе команды service frr status появится строка Status: "FRR Operational".

# All of the FRR daemons can be managed through a single integrated user interface shell called vtysh.

user@FRR:~$ vtysh

Hello, this is FRRouting (version 8.1).
Copyright 1996-2005 Kunihiro Ishiguro, et al.

FRR#

#################### Базовая настройка маршрутизатора на FRR ####################
Ранее мы выяснили, что коммутаторы могут быть неуправляемыми и управляемыми. Любой коммутатор можно достать "из коробки", поставить в сеть, и даже без какой-либо предварительной настройки он будет работать, потому что любой свитч заполняет свою таблицу коммутации автоматически, анализируя входящие кадры, и занося в таблицу коммутации MAC-адрес источника из заголовка входящего кадра и порт, на который пришел этот кадр.

В отличие от них, маршрутизаторы не могут заполнить таблицу маршрутизации автоматически без минимального участия администратора, а значит не могут быть неуправляемыми.
Поэтому есть несколько этапов базовой настройки любого маршрутизатора. Вся настройка FRR-роутера выполняется через интерфейс командной строки. Сам синтаксис команд FRR очень похож на синтаксис CLI операционной системы сетевых устройств Cisco (Cisco IOS), а принцип и иерархия режимов конфигурации идентичны.

После того, как мы зашли в консоль FRR нам необходимо выполнить первоначальную настройку маршрутизатора, которая включает следующие этапы:
    - Задать ему имя
    - Установить пароль на привилегированный режим
    - Настроить IP-адреса на интерфейсах
    - Сохранить конфигурацию

Существует 2 основных контекстных режима интерфейса командной строки: пользовательский (в котором доступен урезанный набор команд диагностики и отсутствует возможность изменения настроек маршрутизатора) и привилегированный (в котором доступны по умолчанию все команды для диагностики, управления и изменения конфигурации).

# Внешний вид строки приглашения (Prompt) в CLI в ПОЛЬЗОВАТЕЛЬСКОМ режиме выглядит так: hostname>.
# По умолчанию имя устройства - frr, и в пользовательском режиме вид командной строки по умолчанию:
frr>

# Для перехода в ПРИВИЛЕГИРОВАННЫЙ режим из пользовательского используется команда enable.
# Внешний вид строки приглашения в CLI в привилегированном режиме - hostname#, по умолчанию он выглядит так:
frr> enable
frr#

# Прежде чем переходить к настройке, необходимо убедиться, что Вы находитесь в привилегированном режиме.
# Полный список всех доступных команд можно просмотреть, набрав в консоли ?
frr# ?

# Также можно использовать ? в качестве подсказки продолжения команды.
# Например, show ? выведет список команд, начинающихся с show.
# Чтобы начать настройку каких-либо параметров маршрутизатора, необходимо зайти в РЕЖИМ ГЛОБАЛЬНОЙ КОНФИГУРАЦИИ с помощью команды configure terminal.
# Переходим в РЕЖИМ ГЛОБАЛЬНОЙ КОНФИГУРАЦИИ:
frr# configure terminal
frr(config)#

# Для возврата из режима конфигурации можно использовать команду exit или клавиатурное сочетание Ctrl+Z.
# При вводе команд удобно использовать функции сокращения (вместо configure terminal можно набрать conf t) и автозаполнения команд с помощью клавиши Tab.
# (config) перед символом # говорит о том, что мы находимся на верхнем уровне иерархии в режиме глобальной конфигурации.
# В этом режиме доступен уже другой набор команд, назначение которых - конфигурирование параметров роутера:
frr(config)# ?

В этом задании мы ограничимся базовыми параметрами, поэтому следующая наша задача - задать hostname на устройстве.
frr(config)# hostname R1
R1(config)#

# Пароль для доступа к консоли в привилегированном режиме, в котором доступны команды настройки, задается командой enable password.
# Чтобы пароли хранились в зашифрованном виде, нужно включить сервис шифрования паролей командой service password-encryption:

R1(config)# enable password pass
R1(config)# service password-encryption
R1(config)# 

# Следующий этап - настройка интерфейсов маршрутизатора.
# Это самый важный этап базовой настройки, потому что в процессе настройки ip-адресов и активации интерфейсов роутер "узнает" о сетях, напрямую подключенных к нему,
# и добавляет информацию о них в свою таблицу маршрутизации.
# Именно эти интерфейсы будут являться шлюзами по умолчанию дляf устройств в сетях, которые они соединяют.

# Перед настройкой конкретного интерфейса убедитесь, что Вы находитесь в режиме глобальной конфигурации (R1(config)#).
# Затем нужно перейти в режим конфигурации интерфейса с заданным именем командой interface <имя интерфейса>.
# Например, если необходимо настроить интерфейс eth0, команда будет выглядеть следующим образом:
R1(config)# interface eth0
R1(config-if)# 

# (config-if) перед символом # говорит о том, что сейчас мы находимся на следующем уровне иерархии - в режиме конфигурации интерфейса.
# Дальнейшие настройки в режиме конфигурации интерфейса выполняются следующим образом:
R1(config)# interface eth0
R1(config-if)# description to_PC1
R1(config-if)# ip address 10.0.2.1/24
R1(config-if)# no shutdown

где
    - с помощью description мы указали описание интерфейса,
    - командой ip address задали ip-адрес и маску в виде префикса на интерфейсе,
    - командой no shutdown (сокращенно no sh) программно включили интерфейс, т.е. перевели его в состояние "up". Если необходимо отключить интерфейс, используется команда shutdown (сокращенно sh).

# Аналогичным образом настраиваются другие интерфейсы.
# Если ошибочно была введена неверная команда, для ее отмены достаточно просто повторить ее с ключевым словом no.
# Например, чтобы изменить ранее настроенный ip-адрес на интерфейсе, необходимо сперва удалить адрес 10.0.2.1/24, а затем назначить новый:
R1# conf t                // то же самое, что и R1# configure terminal
R1(config)# interface eth0
R1(config-if)# no ip address 10.0.2.1/24
R1(config-if)# ip address 10.0.2.254/24

# После всех настроек необходимо сохранить конфигурацию.
# Для этого предварительно нужно вернуться из режима конфигурации в первоначальный привилегированный режим.
# Это можно сделать несколькими способами: 2 раза ввести exit (первый - для возврата из режима конфигурации интерфейса в режим глобальной конфигурации, второй - для возврата еще на уровень выше),
# либо для быстрого перехода командой end или клавиатурным сочетанием Ctrl+Z:
R1(config-if)# end
R1#

# Теперь перейдем к последнему этапу - сохранению конфигурации.
# Пока все выполненные настройки хранятся в оперативной памяти в файле текущей конфигурации running-config.
# Существует также файл с именем startup-config, который загружается при включении или перезагрузке маршрутизатора и хранится в энергонезависимой памяти.
# Для сохранения текущей конфигаруции в качестве стартовой в энергонезависимую память можно использовать любую из следующих команд:
# copy running-config startup-config (сокр. copy run st), write (сокр. wr) или write memory (сокр. wr mem). Например:
R1# write 
Note: this version of vtysh never writes vtysh.conf
Building Configuration...
Integrated configuration saved to /etc/frr/frr.conf
[OK]

# Текущую конфигурацию полностью можно просмотреть командой show running-config (sh run), а стартовую - show startup-config (sh star):
R1# show running-config
R1# show startup-config

# Просмотреть список имен всех интерфейсов и их статус можно командой:
R1# sh interface brief
Interface       Status  VRF             Addresses
---------       ------  ---             ---------
eth0            up      default         10.0.2.1/24
eth1            down    default         
eth2            down    default         
eth3            down    default         
eth4            down    default         
eth5            down    default         
eth6            down    default         
eth7            down    default         
lo              up      default         
lo0             down    defaul

# Вывод текущей таблицы маршрутизации выполняется командой show ip route:
R1# sh ip route
Codes: K - kernel route, C - connected, S - static, R - RIP,
       O - OSPF, I - IS-IS, B - BGP, E - EIGRP, N - NHRP,
       T - Table, v - VNC, V - VNC-Direct, A - Babel, D - SHARP,
       F - PBR, f - OpenFabric,
       > - selected route, * - FIB route, q - queued, r - rejected, b - backup

C>* 10.0.2.0/24 is directly connected, eth0, 02:05:19

# В верхней части вывода - описание кодов-источников маршрутов, после чего строка C>* 10.0.2.0/24 is directly connected, eth0, 02:05:19 показывает,
# что в таблице есть маршрут с кодом C (из описания выше C - connected) в сеть назначения 10.0.2.0/24, которая является напрямую подключенной к интерфейсу eth0,
# а значит пакеты, адресованные в эту сеть, нужно пересылать на eth0.
# Обратите внимание, что данная запись (маршрут) появилась в момент, когда был настроен интерфейс eth0 с ip-адресом 10.0.2.1/24.
# таким образом роутер сам добавил запись о сети 10.0.2.0/24 в таблицу маршрутизации.
# Именно так всегда появляются записи в таблице маршрутизации о напрямую подключенных сетях к интерфейсам маршрутизатора.

# Имеется 2 локальные сети: 192.168.1.0/24 и 192.168.2.0/24, связь между которыми осуществляется с помощью маршрутизатора R1 на FRR.
# Чтобы связать PC1 и PC2 из разных сетей необходимо на них настроить ip-адрес, маску и шлюз, а на R1 (интерфейсы которого и будут являться шлюзами по умолчанию для PC1 и PC2) выполнить базовую настройку.
# Предположим, что на PC1 и PC2 уже настроена адресация и шлюз по умолчанию в соответствии со схемой.
# Тогда на роутере R1 интерфейс eth0, который "смотрит" в сеть 192.168.1.0/24 нужно настроить с адресом 192.168.1.1/24,
# а интерфейс eth1, который "смотрит" в сеть 192.168.2.0/24 - с адресом 192.168.2.1/24.
# Выполним базовую настройку R1 и сохраним конфигурацию:
frr# conf t
frr(config)# hostname R1
R1(config)# enable password rebrain
R1(config)# service password-encryption 
R1(config)# int eth0
R1(config-if)# ip addr 192.168.1.1/24
R1(config-if)# exit
R1(config)# int eth1
R1(config-if)# ip addr 192.168.2.1/24
R1(config-if)# end
R1# write

# После успешного сохранения настроек можно вывести таблицу маршрутизации на R1 и убедиться,
# что там присутствуют записи о напрямую подключенных сетях 192.168.1.0/24 и 192.168.2.0/24 к интерфейсам R1 eth0 и eth1 соответственно:
R1# sh ip route
Codes: K - kernel route, C - connected, S - static, R - RIP,
       O - OSPF, I - IS-IS, B - BGP, E - EIGRP, N - NHRP,
       T - Table, v - VNC, V - VNC-Direct, A - Babel, D - SHARP,
       F - PBR, f - OpenFabric,
       > - selected route, * - FIB route, q - queued, r - rejected, b - backup

C>* 192.168.1.0/24 is directly connected, eth0, 00:02:26
C>* 192.168.2.0/24 is directly connected, eth1, 00:02:07

# Теперь можно проверить связность между PC1 и PC2 командой ping.

############################## ПРАКТИКУМ FRR ##############################
# Проверить, включена ли маршрутизация по умолчанию:
cat /proc/sys/net/ipv4/ip_forward

# Переходим в единую интегрированную оболочку пользовательского интерфейса "vtysh":
vtysh

# Смотрим версию FRR:
FRRouter# show ver

# Смотрим, какие интерфейсы у нас используются:
FRRouter# show interface brief

# Переходим в режим конфигурации:
FRRouter# configure terminal

# Зададим имя программному маршрутизатору:
FRRouter(config)# hostname FRR

# Зададим пароль на вход в привелегированный режим:
FRR(config)# enable password some_password

# Чтобы нам не возвращаться из режима конфигурации в обычный режим, достаточно использовать оператор "do":
FRR(config)# do show running-config

# Видим, что пароль не зашифрован.
# Шифруем пароль:
FRR(config)# service password-encryption

# Переходим к настройкам сетевых интерфейсов.
FRR(config)# interface eth1
FRR(config-if)# ip address 10.10.10.1/24
FRR(config-if)# description PC-101     # указываем, что к этому интерфейсу подключен PC-101

# Включаем интерфейс:
FRR(config-if)# no shutdown

# Проверяем, применилась ли настройка:
FRR(config-if)do show interface brief

# Проверяем связность с PC-101:
FRR(config-if) do ping 10.10.10.101

# Настраиваем интерфейс eth2:
FRR(config)# interface eth2
FRR(config-if)# ip address 20.20.20.1/24
FRR(config-if)# description PC-202     # указываем, что к этому интерфейсу подключен PC-101

# Включаем интерфейс:
FRR(config-if)# no shutdown

# Настраиваем интерфейс eth3:
FRR(config)# interface eth3
FRR(config-if)# ip address 30.30.30.1/24
FRR(config-if)# description PC-303     # указываем, что к этому интерфейсу подключен PC-101


# Возвращаемся из режима конфигурации в обычный режим:
FRR(config-if) ^Z

# Смотрим получившуюся таблицу маршрутизации:
FRR# show ip route

# Настраиваем PC-303

# Добавляем IP-адрес:
ip address add 30.30.30.3/24 dev eth0

# Добавляем шлюз по умолчанию:
ip route add default via 30.30.30.1

# Проверяем настройки шлюза по умолчанию:
ip route

# Проверяем сетевую связность от PC-303 до его шлюза по умолчанию:
ping 30.30.30.1

# Сохраняем настройки нашего роутера:
FRR# copy running-config startup-config

# или
write

############################## NET 15: Статическая маршрутизация ##############################
###################### Добавление статического маршрута в удаленную сеть ######################
########## Правила автоматического создания маршрутов ##########
если выполняются условия:
    - интерфейс, физически подключенный к сети напрямую (directly-connected network), находится в состоянии UP/UP (в активном состоянии);
    - интерфейсу назначен IP-адрес и маска (при этом механизм назначения неважен - статически или динамически по протоколу DHCP),
то для directly-conneted сетей автоматически создаются и добавляются в таблицу маршруты, исходя из назначенного IP-адреса и маски на интерфейсе.
Например, если роутер имеет активный интерфейс eth0 с адресом 10.0.0.1/24, то в таблице маршрутизации автоматически появится маршрут в сеть 10.0.0.0/24, напрямую подключенную к eth0.

# Для примера рассмотрим маршрутизатор на FRR.
# Маршруты в напрямую подключенные сети в таблице маршрутизации будут выглядеть следующим образом:
R1# show ip route
Codes: K - kernel route, C - connected, S - static, R - RIP,
       O - OSPF, I - IS-IS, B - BGP, E - EIGRP, N - NHRP,
       T - Table, v - VNC, V - VNC-Direct, A - Babel, D - SHARP,
       F - PBR, f - OpenFabric,
       > - selected route, * - FIB route, q - queued, r - rejected, b - backup

C>* 10.0.0.0/24 is directly connected, eth0, 00:00:06 # Маршрут в сеть LAN2
C>* 192.168.1.0/24 is directly connected, eth1, 00:00:18 # Маршрут в сеть LAN1

# Локальные маршруты в напрямую подключенные сети почти на всех маршрутизаторах помечаются кодом C, что означает directly-connected.

#################### Добавление статического маршрута в удаленную сеть ####################
# Базовый синтаксис команды для добавления статического маршрута, выполняемой из режима ГЛОБАЛЬНОЙ КОНФИГУРАЦИИ:
ip route <адрес_сети_назначения> <маска_сети_назначения> <next_hop_IP_адрес>

# Дополнительно также можно указать имя исходящего интерфейса и другие параметры. Маску также можно указать в виде префикса:
ip route <адрес_сети_назначения>/<префикс_сети_назначения> <next_hop_IP_адрес>

Рассмотрим схему:
                      LAN1			R1		     LAN2		    R2                      LAN3
PC1(192.168.1.11/24) <---> eth1(192.168.1.1/24)===eth0(10.0.0.1/24) <---> eth0(10.0.0.2/24)===eth1(192.168.2.1/24) <---> PC3(192.168.2.11/24)

# Для R1 транзитным узлом является R2 с интерфейсами eth0(10.0.0.2/24) И eth1(192.168.2.1/24).
# Транзитным узлом должен быть ближайший для R1 интерфейс eth0 маршрутизатора R2 с ip-адресом 10.0.0.2, который и будет next-hop.
# Добавим на R1 статический маршрут в сеть LAN4 192.168.2.0/24:

# Переходим в режим глобальной конфигурации
R1# configure terminal

# Добавляем на R1 статический маршрут в сеть 
R1(config)# ip route 192.168.2.0 255.255.255.0 10.0.0.2

# ИЛИ через префикс сети
R1(config)# ip route 192.168.2.0/24 10.0.0.2

# Выходим из режима глобальной конфигурации:
R1(config)# exit

# Посмотрим, как будет выглядеть таблица маршрутизации на R1 после добавления статического маршрута:
R1# show ip route
Codes: K - kernel route, C - connected, S - static, R - RIP,
       O - OSPF, I - IS-IS, B - BGP, E - EIGRP, N - NHRP,
       T - Table, v - VNC, V - VNC-Direct, A - Babel, D - SHARP,
       F - PBR, f - OpenFabric,
       > - selected route, * - FIB route, q - queued, r - rejected, b - backup

C>* 10.0.0.0/24 is directly connected, eth0, 00:54:17
C>* 192.168.1.0/24 is directly connected, eth1, 00:54:29
S>* 192.168.2.0/24 [1/0] via 10.0.0.2, eth0, weight 1, 00:00:09 # маршрут в LAN4

# Видно, что в таблице маршрутизации на R1 последняя строка - это статический маршрут (код источника маршрута - S - static) в сеть назначения 192.168.2.0/24,
# которая достижима через 10.0.0.2 и собственный исходящий интерфейс eth0.


                      LAN1			R1		     LAN2		    R2                      LAN3
PC1(192.168.1.11/24) <---> eth1(192.168.1.1/24)===eth0(10.0.0.1/24) <---> eth0(10.0.0.2/24)===eth1(192.168.2.1/24) <---> PC3(192.168.2.11/24)

# Но для связности между PC1 и PC3 этого недостаточно.
# Пока что связь будет работать только в одном направлении - из LAN1 в LAN4.
# Но также нужно, чтобы из LAN4 был известен обратный путь в LAN1.
# Для этого аналогичный статический маршрут нужно добавить на R2 в удаленную для него сеть LAN1 (192.168.1.0/24) через транзитный для него next-hop 10.0.0.1.

R2# conf t
R2(config)# ip route 192.168.1.0/24 10.0.0.1
R2(config)# exit

# ВЫВОД: на каждом маршрутизаторе в топологии должны быть известны все маршруты в удаленные для них сети, чтобы была полная свзяность между всеми сетями.

#################### Просмотр всех добавленных статических маршрутов в текущей конфигурации ####################
# Список всех добавленных статических маршрутов в конфигурации можно просмотреть командой вывода текущей конфигурации с фильтром по ключевым словам ip route:
show running-config | include ip route

#################### Просмотр только статических маршрутов в результирующей таблице маршрутизации ####################
# Если необходимо вывести не всю текущую таблицу маршрутизации, а только статические маршруты в ней, можно использовать команду:
show ip route static

#################### Удаление статического маршрута ####################
# Для удаления статического маршрута из конфигурации используется конструкция вида:
# no <команда,в результате которой был добавлен статический машрут>.
# Например, если нужно удалить статический маршрут, который ранее был добавлен в сеть назначения 10.0.3.0/24 через 10.0.1.10, команда будет выглядеть следующим образом:
no ip route 10.0.3.0/24 10.0.1.10

#################### Next-hop IP-адрес из удаленной сети ####################

# Next-hop адрес не всегда может быть из directly-connected для маршрутизатора сети.
# Почти во всех случаях следует указывать next-hop адрес из напрямую подключенной сети, но для более глубокого понимания разберем следующий пример:
                      LAN1			R1		     LAN2		     R2                      LAN3                       R3                       LAN4 
PC1(192.168.1.11/24) <---> eth1(192.168.1.1/24)===eth0(10.0.0.1/24) <----> eth0(10.0.0.2/24)===eth1(172.16.30.1/24) <----> eth0(172.16.30.2/24)====eth1(192.168.2.1/24) <----> PC3(192.168.2.11/24) 

# Рассмотрим на практическом примере случай со специфичным маршрутом до транзитного узла.
# После настройки интерфейсов на R1 таблица маршрутизации выглядит так:
R1# show ip route
Codes: K - kernel route, C - connected, S - static, R - RIP,
       O - OSPF, I - IS-IS, B - BGP, E - EIGRP, N - NHRP,
       T - Table, v - VNC, V - VNC-Direct, A - Babel, D - SHARP,
       F - PBR, f - OpenFabric,
       > - selected route, * - FIB route, q - queued, r - rejected, b - backup

C>* 10.0.0.0/24 is directly connected, eth0, 00:00:28
C>* 192.168.1.0/24 is directly connected, eth1, 00:00:09

# Добавим маршрут сразу к сети LAN4:
R1#conf t
R1#(config)# ip route 192.168.2.0 255.255.255.0 172.16.30.2
R1#(config)# end

# Выведем статические маршруты в текущей конфигурации на R1:
R1# show running-config staticd 
Building configuration...
Current configuration:
!
frr version 7.5.1
frr defaults traditional
hostname R1
service integrated-vtysh-config
!
ip route 192.168.2.0/24 172.16.30.2 # В конфигурации маршрут появился
!
line vty
!
end

# Выведем результирующую таблицу маршрутизации на R1:
R1# show ip route
Codes: K - kernel route, C - connected, S - static, R - RIP,
       O - OSPF, I - IS-IS, B - BGP, E - EIGRP, N - NHRP,
       T - Table, v - VNC, V - VNC-Direct, A - Babel, D - SHARP,
       F - PBR, f - OpenFabric,
       > - selected route, * - FIB route, q - queued, r - rejected, b - backup

C>* 10.0.0.0/24 is directly connected, eth0, 00:03:55
C>* 192.168.1.0/24 is directly connected, eth1, 00:03:36 # А вот в результирующей таблице маршрутизации - нет

# Видим, что в таблице по-прежнему только 2 доступных маршрута.

# Теперь добавим маршрут в сеть, в которой расположен транзитный узел (помним, что сеть LAN3, в которой расположен транзитный узел, находится за R2,
# который в свою очередь имеет интерфейс в напрямую подключенной сети для маршрутизатора R1, адрес интерфейса которого из этой сети и выберем в качестве next-hop):
R1(config)# ip route 172.16.30.0/24 10.0.0.2
R1(config)# exit
R1# show running-config staticd 
Building configuration...

Current configuration:
!
frr version 7.5.1
frr defaults traditional
hostname R1
service integrated-vtysh-config
!
ip route 172.16.30.0/24 10.0.0.2 # Новый маршрут добавился в конфигурацию
ip route 192.168.2.0/24 172.16.30.2
!
line vty
!
end

# Снова выведем результирующую таблицу маршрутизации на R1:
R1# show ip route
Codes: K - kernel route, C - connected, S - static, R - RIP,
       O - OSPF, I - IS-IS, B - BGP, E - EIGRP, N - NHRP,
       T - Table, v - VNC, V - VNC-Direct, A - Babel, D - SHARP,
       F - PBR, f - OpenFabric,
       > - selected route, * - FIB route, q - queued, r - rejected, b - backup

C>* 10.0.0.0/24 is directly connected, eth0, 00:10:20
S>* 172.16.30.0/24 [1/0] via 10.0.0.2, eth0, weight 1, 00:00:09 # Новый маршрут в сеть LAN3
C>* 192.168.1.0/24 is directly connected, eth1, 00:10:01
S>  192.168.2.0/24 [1/0] via 172.16.30.2 (recursive), weight 1, 00:00:09
  *                        via 10.0.0.2, eth0, weight 1, 00:00:09 # И маршрут в сеть LAN4, через сеть LAN3

# Так как адрес 10.0.0.2 для R1 доступен и находится в напрямую подключенной сети 10.0.0.0/24,
# то маршрут в LAN3 без проблем добавился в таблицу на R1, а когда добавился маршрут в LAN3 - появилась связность с транзитным узлом в LAN4, и этот маршрут также добавился в таблицу.

# Маршрутизация - процесс автономный для каждого роутера: маршрутизатору важно перенаправить пакет через собственный интерфейс,
# однако после этого роутер не несет ответственности за дальнейший путь пакета в сеть назначения.
# Поэтому в разобранном выше примере достаточным для сетевой связности также было бы указать на R1 маршрут вида ip route 192.168.2.0/24 10.0.0.2/24,
# т.е. отдать право выбирать дальнейший путь следования пакета уже R2.

#################### Маршут по умолчанию как особый вид статического маршрута ####################
# Маршрут по умолчанию в cli FRR задается в следующем формате:
ip route 0.0.0.0 0.0.0.0 <next-hop ip-адрес>
# ИЛИ
ip route 0.0.0.0/0 <next-hop ip-адрес>

# В консоли FFR-маршрутизатора такой маршрут настраивается в режиме глобальной конфигурации и отображается так:
R1# conf t
R1(config)# ip route 0.0.0.0 0.0.0.0 1.2.3.5
R1(config)# exit

R1# show running-config staticd 
Building configuration...

Current configuration:
!
frr version 7.5.1
frr defaults traditional
hostname R1
service integrated-vtysh-config
!
ip route 0.0.0.0/0 1.2.3.5 # в конфигурации появился
!
line vty
!
end
R1# show ip route
Codes: K - kernel route, C - connected, S - static, R - RIP,
       O - OSPF, I - IS-IS, B - BGP, E - EIGRP, N - NHRP,
       T - Table, v - VNC, V - VNC-Direct, A - Babel, D - SHARP,
       F - PBR, f - OpenFabric,
       > - selected route, * - FIB route, q - queued, r - rejected, b - backup

S>* 0.0.0.0/0 [1/0] via 1.2.3.5, eth1, weight 1, 00:00:05 # наш маршрут по умолчанию
C>* 192.168.0.0/24 is directly connected, eth1, 00:02:12
C>* 192.168.1.0/24 is directly connected, eth0, 00:02:02

########## Преимущества и недостатки статической маршрутизации ##########
Преимущества статической маршрутизации:
    - простота внедрения (что актуально только для небольших сетей);
    - относительно высокий уровень безопасности (трафик следует только по тем маршрутам, которые указал сетевой инженер или системный администратор);
    - маршрут остается неизменным в рамках настроенной конфигурации (маршруты, добавленные с помощью протоколов динамической маршрутизации могут меняться,
      статический маршрут остается постоянным до момента изменения или удаления вручную);
    - меньшая нагрузка на роутер (нет потребности в дополнительных аппаратных ресурсах, используемых для работы протоколов динамической маршрутизации).

Недостатки статической маршрутизации:
    - статические маршруты подходят только для относительно небольших сетей: чем больше сеть, тем больше маршрутов нужно добавлять вручную, а значит больше вероятность ошибки и человеческого фактора;
    - сложность и объем конфигурации значительно, порой драматически, вырастает по мере роста сети;
    - если необходимо внести изменения в конфигурацию - нужно выполнять их вручную на большом количестве устройств.

############################## NET 17: Динамическая маршрутизация. OSPF для одной области ##############################
############################## NET 18: Динамическая маршрутизация. OSPF для нескольких областей ########################
Типы протоколов ДИНАМИЧЕСКОЙ маршрутизации:
- Дистанционно-векторные протоколы (Distance Vector Protocols):
  --> RIP v2
  --> EIGRP (каждый роутер как "слепой котенок" не знает, как устроена сеть; не может гарантировать, что маршрут не содержит петель; поддерживается только Cisco)
- Протоколы состояния каналов связи (Link-State Protocols)
  --> OSPF (каждый роутер имеет полную карту сети, быстрее реагирует на изменение конфигурации сети; поддерживается всеми вендорами - мультивендорный)
  --> IS-IS
- Протоколы выбора маршрута по пути (Path Vector Protocols)
  --> BGP
  
