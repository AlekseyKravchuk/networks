# Физические параметры сетевого интерфейса, такие как скорость и дуплекс, настраиваются с помощью утилиты ethtool (входит в состав пакета ethtool).
# Устанавливаемв пакет 'ethtool'
sudo apt-get install ethtool

#Установка пакета 'net-tools':
sudo apt-get install net-tools

# Посмотреть список сетевых интерфейсов можно с помощью команды ifconfig из пакета net-tools,
# либо с помощью команд 'ip address' или 'ip link' из более современного пакета iproute2
ip address  ## или сокращенно: ip a

# Если интерфейс находится в состоянии DOWN, перевести его в состояние UP можно разными способами, например:
# => с помощью команды ip link:
sudo ip link set <interface_name> up

# => с помощью команды ifconfig:
sudo ifconfig <interface_name> up

# Для настройки физических параметров сетевого адаптера используется команда ethtool <имя адаптера> с разными ключами.
# Посмотреть текущие параметры можно с помощью команды:
ethtool <interface_name>

ethtool enx0c5b8f279a64  # пример команды с именем реального интерфейса

# Иногда встречаются ситуации, когда при неудачном автосогласовании может установиться, например, полудуплексный режим.
# Этот режим катастрофически снижает реальную скорость и производительность сети, поэтому важно, чтобы дуплекс всегда был полным.
# Пересогласование параметров можно инициировать командой:
sudo ethtool -r <interface_name>  # пересогласование параметров

ethtool -r enx0c5b8f279a64  # пример команды с именем реального интерфейса

# Для проверки сетевой связности между двумя устройствами в подавляющем большинстве случаев используется утилита ping из пакета iputils-ping, установка которого выполняется командой:
sudo apt-get install iputils-ping

# Среди вывода команры "ethtool" есть очень интересный параметр - "Supports Wake-on: pumbg" - с его помощью можно удаленно включить машину
kav@vak:~$ sudo ethtool enp37s0
Settings for enp37s0:
	Supported ports: [ TP	 MII ]
	Supported link modes:   10baseT/Half 10baseT/Full
	                        100baseT/Half 100baseT/Full
	                        1000baseT/Full
	Supported pause frame use: Symmetric Receive-only
	Supports auto-negotiation: Yes
	Supported FEC modes: Not reported
	Advertised link modes:  10baseT/Half 10baseT/Full
	                        100baseT/Half 100baseT/Full
	                        1000baseT/Full
	Advertised pause frame use: Symmetric Receive-only
	Advertised auto-negotiation: Yes
	Advertised FEC modes: Not reported
	Speed: Unknown!
	Duplex: Unknown! (255)
	Auto-negotiation: on
	master-slave cfg: preferred slave
	master-slave status: unknown
	Port: Twisted Pair
	PHYAD: 0
	Transceiver: external
	MDI-X: Unknown
	Supports Wake-on: pumbg
	Wake-on: d
	Link detected: no

# поменять MAC-адрес на сетевом интерфейсе
sudo ip link set dev eth0 down                  # предварительно временно выключаем интерфейс
ip link set dev eth0 address 1a:2b:3c:4d:5e:6f
sudo ip link set dev eth0 up                    # снова включаем интерфейс

# Наиболее распространенные утилиты из пакета iproute2:
# Утилита ip позволяет нама получать информацию о параметрах интерфейсов L2, L3 и менять их настройки

# Утилита tc (от traffic control) - позволяет нам просматривать конфигурацию управления трафиком

# Утилита ss (аналог netstat) - позволяет просматривать текущие соединения и открытые порты на нашем устройстве.

# Если на устройстве присутствует много интерфейсов, то можно ограничить вывод информации одним интерфейсом:
ip link show dev enx0c5b8f279a64

# Выключить необходимый интерфейс:
ip link set enx0c5b8f279a64 down

# ВКЛЮЧИТЬ необходимый интерфейс:
ip link set enx0c5b8f279a64 up

# ==================================
Networks by Rebrain: Основы IP адресации
https://www.youtube.com/watch?v=-MEXqJLZVg4&t=4s


Любые 2 устройства могут взаимодействовать друг с другом только в том случае, если их ip-адреса из одного диапазона.
Для логической идентификации устройства и определения принадлежности его к конкретной сети нужен ip-адрес.

ip-адрес - это уникальное число, которое используется для логической идентификации устройства в сети.    
ip_address = сетевая_часть_адреса(net_id) + узловая_часть_адреса(host_id)
ip_address = net_id + host_id

Задача: даны 3 ip-адреса: 190.100.5.115, 190.100.6.113, 190.101.0.1
Требуется определить, находятся ли эти адреса в одном диапазоне (в одной подсети) или нет?

Чтобы ответить на этот вопрос нужно четко знать, где проходит граница между сетевой и хостовой(узловой) частями адреса (между net_id и host_id).

Класс A: /8
Класс B: /16
Класс C: /24

Маска подсети позволяет установить границу между сетевой и хостовой частью адреса.
Маска - это такое же 32-битное число (шаблон), в котором в левой его части записываются единицы (они указывают на СЕТЕВУЮ часть адреса),
а в правой его части - нули (они указывают на УЗЛОВУЮ часть адреса).
Единицы в маске указывают на сетевую часть адреса; нули в маске указывают на хостовую (узловую) часть адреса.

При наложении AND-маски на ip-адрес выделяется сетевая часть.
Когда требуется выделить сетевую часть адреса, используется побитовое наложение маски на ip-адрес с помощью поразрядной операции "И" (&).
net_ip = ip & mask

Результатом наложения маски сети на ip-адрес является также число, которое называется адресом сети или сетевым адресом.
Хостовая (узловая) часть сетевого адреса заполнена нулями.

Маску сети можно записать в виде префикса: /1, /2, ..., /8, .../16, /17, ..., /24, ..., /30, /31, /32.
Префикс - это количество единиц в маске.

Задача 1: найти адрес сети для ip-адреса 192.168.1.73/26
  11000000.10101000.00000001.01|001001
& 11111111.11111111.11111111.11|00000
  11000000.10101000.00000001.01|00000
  192.168.1.64  - net_ip
  192.168.1.192 - mask
  
Задача 2: Проверить принадлежность ip-адресов одной сети:
192.168.1.43/26 и 192.168.1.67/26
11000000.10101000.00000001.00|101011 192.168.1.43/26
11000000.10101000.00000001.01|000011  192.168.1.67/26

Задача 3: Какие адреса являются корректными адресами сети?
Корректным адресом сети является такой адрес, у которого в хостовой части все разряды заполнены нулями.
192.23.41.0/24  11000000.00010111.00101001.|00000000  // все разряды в хостовой части заполнены нулями => это корректный адрес сети
1.1.15.0/21     00000001.00000001.00001|111.00000000  // в хостовой части первые три бита - единицы => это НЕ корректный адрес сети
127.0.0.32/27   01111111.00000000.00000000.001|00000  // корректный адрес сети
  
# ================= Broadcast (широковещательный) адрес =================
broadcast-адрес - это ещё один служебный адрес, т.е. его нельзя назначать устройствам сети.
broadcast-адрес используется для отправки пакетов всем узлам сети.
По определению broadcast-адрес - это адрес, у которого хостовая часть заполнена всеми единицами.

Пусть имеется адрес сети (network ip-address): 190.100.0.0/16
10111110.01100100.|00000000.00000000
11111111.11111111.|00000000.00000000 mask

Нужно найти широковещательный адрес.
11111111.11111111.00000000.00000000 mask
  00000000.00000000.|11111111.11111111 ~mask
| 10111110.01100100.|00000000.00000000 network_ip
  10111110.01100100.|11111111.11111111 broadcast_ip (190.100.255.255)

broadcast_ip = ip | ~mask
~mask ещё называют wildcard-маска

Задача 5. Что из перечисленного ниже является адресом широковещательной рассылки в сети класса B с маской подсети по умолчанию?
Подсказка: Класс B: net.net.host.host: 10xxxxxx.X.X.X (128-191.X.X.X.X)
172.16.10.255    10101100.00010000.|00001010.11111111  # НЕТ
172.16.255.255   10101100.00010000.|11111111.11111111  # ДА
172.255.255.255  10101100.11111111.|11111111.11111111  # ДА
255.255.255.255  11111111.11111111.|11111111.11111111  # НЕТ

Задача 5.2
Рассчитать broadcast-адрес для ip-адреса 192.168.1.73/26
11000000.10101000.00000001.01|001001 ip_addr
11111111.11111111.11111111.11|000000 mask
00000000.00000000.00000000.00|111111 ~mask

   11000000.10101000.00000001.01|001001 ip_addr
|  00000000.00000000.00000000.00|111111 ~mask
   11000000.10101000.00000001.01|111111 broadcast_ip (bin)
   192.168.1.127 broadcast_ip (dec)
   
# Расчет диапазона адресов устройств (unicast-адресов)
Для назначения ip-адресов можно назначать весь диапазон адресов, кроме net_ip и broadcast_ip.
Потому что любой unicast-адрес в хостовой части представляет собой некоторую комбинацию из нулей и единиц.
Кроме комбинации со всеми нулями (это будет служебный адрес сети, net_ip).
Кроме комбинации со всеми единицами (это будет служебный широковещательный адрес, broadcast_ip)

В заданном диапазоне ПЕРВЫМ доступным ip-адресом будет:    first_ip_in_range = net_ip + 1
В заданном диапазоне ПОСЛЕДНИМ доступным ip-адресом будет: last_ip_in_range  = broadcast_ip - 1

Пример. Для адреса 192.168.1.73/26 net_ip = ip & mask.
  11000000.10101000.00000001.01|001001 ip
& 11111111.11111111.11111111.11|000000 mask
  11000000.10101000.00000001.01|000000 net_ip (bin)
  192.168.1.64                         net_ip (dec)
  
first_ip_in_range = net_ip + 1 = 192.168.1.64 + 1 = 192.168.1.65
last_ip_in_range  = broadcast_ip - 1 = 192.168.1.127 - 1 = 192.168.1.126
Т.о. устройствам можно назначать ip-адреса из следующего диапазона: [192.168.1.65; 192.168.1.126]

Задача 6. Сгенерировать конфигурацию для dhcpd-сервера
subnet 172.16.8.0 netmask 255.255.252.0 {
        authoritative;
	option domain-name-servers 8.8.4.4, 8.8.8.8;
	option routers 172.16.8.1;
	oprion subnet-mask 255.255.252.0;
}

# --------> пишем функцию для перевода ip-адреса из строки в точечно-десятичном формате в целое число
ip_str = '192.168.1.2'
octs = [int(x) for x in ip_str.split('.')]  # octs = [192, 168, 1, 2]

octs[0] = 192 = 00000000 00000000 00000000 11000000
octs[1] = 168 = 00000000 00000000 00000000 10101000
octs[2] = 1   = 00000000 00000000 00000000 00000001
octs[3] = 2   = 00000000 00000000 00000000 00000010
Теперь октеты нужно сконкатенировать таким образом, чтобы получилось одно число:
bin:    192      168      1        2
dec: 11000000 10101000 00000001 00000010

octs[0] << 24: 11000000 00000000 00000000 00000000 : 192  0   0   0 
octs[1] << 16: 00000000 10101000 00000000 00000000 : 0   168  0   0
octs[2] << 8 : 00000000 00000000 00000001 00000000 : 0    0   1   0
octs[3]      : 00000000 00000000 00000000 00000010 : 0    0   0   2
concatenated : 11000000 10101000 00000001 00000010 : 11000000101010000000000100000010

Итого, результирующий ip-адрес (как число): octs[0] << 24 | octs[1] << 16 | octs[2] << 8 | octs[0]

# --------> Обратная задача: пишем функцию для перевода ip-адреса  в точечно-десятичном формате в число (int)
Есть исходный ip-адрес = 3232235778 (192.168.1.2)
11000000.10101000.00000001.00000010
11000000.10101000.00000001.00000010 >> 24 = 0000000.0000000.00000000.11000000

11000000.10101000.00000001.00000010 >> 16 = 0000000.0000000.11000000.10101000
   0000000.0000000.11000000.10101000
&  0000000.0000000.00000000.11111111
(11000000.10101000.00000001.00000010 >> 16) & 255

11000000.10101000.00000001.00000010 >> 8 = 00000000.11000000.10101000.00000001
   00000000.11000000.10101000.00000001
&  00000000.00000000.00000000.11111111
(11000000.10101000.00000001.00000010 >> 8) & 255

11000000.10101000.00000001.00000010
   11000000.10101000.00000001.00000010
&  00000000.00000000.00000000.11111111
(11000000.10101000.00000001.00000010) & 255

# --------> Вычисляем broadcast
По определению broadcast-адрес - это адрес, у которого хостовая часть заполнена всеми единицами.
ip = 3232235778 (192.168.1.2/24) = 11000000.10101000.00000001.00000010
mask = 255.255.255.0             = 11111111.11111111.11111111.00000000
net_ip = ip & mask = 192.168.1.0 = 11000000.10101000.00000001.00000000

broadcast_ip = ip | ~mask       =    11000000.10101000.00000001.00000010
	       	    		   & 00000000.00000000.00000000.11111111
К сожалению, в Python операция побитового отрицания работает не так, как в С++, то нужно использовать искусственный прием.
Как же вычислить ~mask в Python?
вот наша маска: 11111111.11111111.11111111.00000000 (255.255.255.0)
нужно получить: 00000000.00000000.00000000.11111111 (0  .  0.  0.255)

Какая побитовая операция позволит это сделать?

11111111.11111111.11111111.00000000
XOR(^)
11111111.11111111.11111111.11111111  (0xFFFFFFFF)


Задача 7: Сколько хостов можно разместить в сети 190.100.0.0/21?
Количество хостов, которые поместятся в сети равно количеству уникальных комбинаций, которые можно составить из хостовой порции данного ip-адреса за вычетом
двух запрещенных комбинаций - со всеми нулями (net_ip) и со всеми единицами (broadcast_ip).
N = 2**n - 2 // где n - это количество бит в узловой части адреса
32 - 21 = 11 бит в в узловой части адреса
N = 2**11 - 2 = 2046

Задача 8: В сети нужно разместить 256 устройств. Какую маску выбрать?
Т.е. сколько нужно иметь бит в хостовой части адреса, чтобы составить заданное значение уникальных комбинаций.
Т.о. нужно найти ближайшую степень двойки, при возведении в которую получится число, большее или равное требуемому количеству устройств + 2 (net_ip и broadcast_ip ).
32 - (log2(N+2) -> ∞)

В Python:
math.log(256 + 2, 2) = 8.011227255423254; 
32 - math.ceil(math.log(256 + 2, 2)) = 23 бита => маска должна быть /23

# ===================== Специальные IPv4-адреса =====================
Интерфейс обратной петли (loopback): 127.0.0.1 (127.0.0.0 - 127.255.255.255 - зарезервированы)
Локальный адрес канала: 169.254.0.0 - 169.254.255.255 (169.254.0.0/16) - служба APIPA
Адреса TEST-NET: 192.0.2.0 - 192.0.2.255 (192.0.2.0/24) - для образовательных и обучающих целей
Экспериментальные адреса: 240.0.0.0 - 255.255.255.254
Мультикаст-адреса (адреса групповой рассылки): 224.0.0.0 - 239.255.255.255

# ===================== Частные IPv4-адреса =====================
Кроме специальных ip-адресов существуют адреса, которые никогда ни при каких обстоятельствах не маршрутизируются в сети Интернет и не могут использоваться для адресации устройств в Интернете.
Их называют частными (private) адресами. Эти адреса используются исключительно для адресации внутри изолированных частных локальных корпоративных сетей.
       Диапазон		         Маска      Количество узлов
10.0.0.0 - 10.255.255.255.255	  /8             ~16.5 млн.
172.16.0.0 - 172.32.255.255       /16            ~65.5 тыс.
192.168.0.0 - 192.168.255.255     /24             254

# ===================== ИТОГИ  =====================
net_ip = ip & mask
broadcast_ip = ip | ~mask
1st_ip = net_ip + 1
last_ip = broadcast_ip - 1


# ===================== РАЗБИЕНИЕ СЕТЕЙ НА ПОДСЕТИ  =====================
https://www.youtube.com/watch?v=SOZXLPvsFsQ&list=PL_jzYoo7u8dGpqTl6quYwZ_EFzmN75BXE&index=7

Процедура разделения сети на подсети:
Базовый адрес сети: 192.168.1.0/24 - это общее адресное пространство, которое мы будем делить на подсети.
Базовый адрес сети нам нужно разбить на 2 поддиапазона и сделать это таким образом, чтобы:
1) они не пересекались между собой,
2) но чтобы они были частью общего адресного пространства 192.168.1.0/24

Чтобы выполнялось условие 2) нужно, чтобы все адреса и в одной, и в другой подсети начинались на 192.168.1. ...
Общая часть <192.168.1> всегда должна оставаться неизменной, сколько бы мы ни делали подсетей в рамках одной сети.

Итак, для создания двух подсетей выделяют 1 бит из узловой части базового адреса и переносят его в сетевую часть.
Для первой подсети значение этого (перенесенного из сетевой части) бита выставляют в 0, в для второй подсети этот бит высталяют в 1:
1-ая подсеть: 192.168.1.0|0000000;
2-ая подсеть: 192.168.1.1|0000000;
                       ^ ^
		       | |
В результате граница между сетевой и хостовой порцией сдвигается на 1 бит вправо.
Что будет с новой маской, которая получится у каждой подсети?
Маска станет /25.

Что будет с хостовой порцией в каждой из 2-х новых подсетей?
Она станет на 1 бит меньше, т.е. 7 бит  => в каждой из организованных подсетей поместится 2**7 - 2 = 128 - 2 = 126 сетевых устройств.

В итоге мы получили 2 подсети с маской /25 (255.255.255.128). И обе они являются частью общего адресного пространства 192.168.1

Сетевой адрес для 1-ой подсети: 192.168.1.0|0000000 = 192.168.1.0/25
Сетевой адрес для 2-ой подсети: 192.168.1.1|0000000 = 192.168.1.128/25

Теперь для каждой из двух подсетей можно посчитать по известным формулам:
- broadcast_ip
- 1st_ip
- last_ip

#################### 1-ая подсеть ####################
Сетевой адрес (net_ip) для 1-ой подсети: 192.168.1.0|0000000 = 192.168.1.0/25

маска /25 = 255.255.255.128 =             1111111111111111111111111|0000000

broadcast_ip = 192.168.1.0/25 | ~mask =   11000000.10101000.00000001.0|0000000 - сетевой адрес для 1-ой подсети
	       		      	        | 00000000.00000000.00000000.0|1111111 - ~mask
					  11000000.10101000.00000001.0|1111111 = 192.168.1.127

1st_ip = net_ip + 1 = 192.168.1.0/25 + 1 = 192.168.1.1
last_ip = broadcast_ip - 1 = 192.168.1.126

#################### 2-ая подсеть ####################
Сетевой адрес (net_ip) для 2-ой подсети: 192.168.1.1|0000000 = 192.168.1.128/25

маска /25 = 255.255.255.128 =             1111111111111111111111111|0000000

broadcast_ip = 192.168.1.1/25 | ~mask =   11000000.10101000.00000001.1|0000000 - сетевой адрес для 2-ой подсети
	       		      	        | 00000000.00000000.00000000.0|1111111 - ~mask
					  11000000.10101000.00000001.1|1111111 = 192.168.1.255

1st_ip = net_ip + 1 = 192.168.1.128/25 + 1 = 192.168.1.129
last_ip = broadcast_ip - 1 = 192.168.1.255 - 1 = 192.168.1.254

# ===================== РАЗБИЕНИЕ СЕТИ НА 4 ПОДСЕТИ  =====================
Адрес сети - это адрес, у которого в хостовой порции ВСЕ нули.

Пусть базовый адрес сети (net_ip) = 192.168.1.0/24
Тогда общая маска для 4-х подсетей = 192.168.1.11|000000 = 192.168.1.192
Подсеть 1: 192.168.1.00|000000/26 = 192.168.1.0/26
	   broadcast_ip = 192.168.1.63
	   1st_ip = subnet_ip + 1 = 192.168.1.0 + 1 = 192.168.1.1
	   last_ip = broadcast_ip - 1 = 192.168.1.63 - 1 = 192.168.1.62
	   
Подсеть 2: 192.168.1.01|000000/26 = 192.168.1.0.64/26
	   broadcast_ip = 192.168.1.127
	   1st_ip = subnet_ip + 1 = 192.168.1.64 + 1 = 192.168.1.65
	   last_ip = broadcast_ip - 1 = 192.168.1.127 - 1 = 192.168.1.126

Подсеть 3: 192.168.1.10|000000/26 = 192.168.1.128/26
	   broadcast_ip = 192.168.1.191
	   1st_ip = subnet_ip + 1 = 192.168.1.128 + 1 = 192.168.1.129
	   last_ip = broadcast_ip - 1 = 192.168.1.191 - 1 = 192.168.1.190

Подсеть 4: 192.168.1.11|000000/26 = 192.168.1.192/26
	   broadcast_ip = 192.168.1.255
	   1st_ip = subnet_ip + 1 = 192.168.1.192 + 1 = 192.168.1.193
	   last_ip = broadcast_ip - 1 = 192.168.1.255 - 1 = 192.168.1.254

Итог: при выделении из хостовой порции адреса 2-х бит мы можем организовать из одной базовой сети /24 ровно 4 подсети /26.

# ===================== РАСЧЕТ КОЛИЧЕСТВА ПОДСЕТЕЙ  =====================
Nподсетей = 2^k, где k - количество бит, выделенных из узловой части адреса
Например, для создания 3-х подсетей нам потребуется забрать 3 бита из хостовой порции 2^3 = 8

Расчет количества бит, которые необходимо выделить из узловой части базового адреса для создания нужного количества подсетей.
from math import log2
from math import ceil
N = 8          # N - количество подсетей, которые необходимо создать
ceil(log2(N))  # количество бит, необходимое для организации N штук подсетей

# ############################## ЗАДАЧА на разбиение сети на подсети ####################
По какому принципу и по какому алгоритму вы будете делить сеть на подсети, как вы будете это делать?
Дан некоторый базовый адрес сети (общее адресное пространство): 172.16.8.0/22.
Указанное общее адресное пространство (базовый адрес сети) нужно разбить на N-ное количество подсетей и для каждой такой подсети вычислить:
	  - адрес подсети;
	  - broadcast_ip;
	  - 1st_ip;
	  - last_ip;
	  - диапазон IP-адресов, которые можно назначать клиентам.
 
Сгенерировать конфигурационные файлы dhcpd-сервера для этих 10 подсетей.
Соответственно, для каждой из подсетей нужно сгенерировать свой файлик test0.net, test1.net, ..., test9.net, в котором будет некоторое следующее содержимое:
test0.net (в каждом таком файлике описывается своя подсеть):

subnet 172.16.8.0 netmask 255.255.255.192 {
       authoritative;
       option domain-name-servers 8.8.4.4, 8.8.8.8;
       option routers 172.16.8.1;
       option subnet-mask 255.255.255.192;
}

pool { allow members of "users" "cl-floor0-0"; deny dynamic bootp clients; range 172.16.8.2; }
pool { allow members of "users" "cl-floor0-1"; deny dynamic bootp clients; range 172.16.8.3; }
pool { allow members of "users" "cl-floor0-2"; deny dynamic bootp clients; range 172.16.8.4; }
...
pool { allow members of "users" "cl-floor0-N"; deny dynamic bootp clients; range 172.16.8.62; }

##################################################	 
для организации N=2 подсетей нам нужно перекинуть 1 бит из хостовой в новую сетевую часть адреса
подсети: 0, 1
число N=2 в бинарном представлении = 0b10
==> 0b10 - 1 = 0b01 (одна единица в получившемся числе -> нужно перебросить 1 бит)
##################################################

для организации N=4 подсетей нам нужно перекинуть 2 бита из хостовой в новую сетевую часть адреса
подсети: 00, 01, 10, 11
число N=4 в бинарном представлении = 0b100
==> 0b100 - 1 = 0b011 (2 единицы в получившемся числе -> нужно перебросить 2 бита)
##################################################
для организации N=8 подсетей нам нужно перекинуть 3 бита из хостовой в новую сетевую часть адреса
подсети: 000, 001, 010, 011, 100, 101, 110, 111
число N=8 в бинарном представлении = 0b1000
==> 0b1000 - 1 = 0b0111 (3 единицы в получившемся числе -> нужно перебросить 3 бита)
##################################################
для организации N=16 подсетей нам нужно перекинуть 4 бита из хостовой в новую сетевую часть адреса
подсети: 0000, 0001, 0010, 0011, 0100, 0101, 0110, 0111, 1000, 1001, 1010, 1011, 1100, 1101, 1110, 1111
число N=16 в бинарном представлении = 0b10000
==> 0b10000 - 1 = 0b01111 (4 единицы в получившемся числе -> нужно перебросить 4 бита)

Если количество подсетей, которые требуется создать, соответствует степени двойки, то с помощью такого нехитрого расчета:
N_digits = N - 1   # количество единиц, которые нужно перебросить из хостовой порции адреса в новую сетевую порцию.
Всё бы ничего, если бы у нас количество требуемых подсетей всегда было равно какой-то степени двойки.

Но нам нужно организовать 10 подсетей + нужно написать универсальный скрипт.
N = 10 = 0b1010; 0b1010 - 1 = 0b1001 = 9 - такой способ не подходит.
Но мы однозначно знаем позицию первого установленного бита в числе: pos_leftmost_bit = 3 (zero-based).
Теперь, если мы добьем все позиции справа от pos_leftmost_bit единицами, то получим количество N_digits.

N = 10 подсетей
####################
10 = 0...1010
0...1010 >> 1 = 0...0101 (5)
0...1010 (10)
|
0...0101 (5)
=
0...1111 (N стало равно 15)
####################n
0...1111 >> 2 = 0...0011 (3)
0...1111 (15)
|
0...0011 (3)
=
0...1111 (15)
####################
0...1111 >> 4 = 0...0000 (0)
0...1111
|
0...000
=
0...1111
####################
0...1111 >> 8 = 0...0000 (0)
0...1111
|
0...0000
=
0...1111
####################
0...1111 >> 16 = 0...0000 (0)
0...1111
|
0...0000
=
0...1111

#################### Маски переменной длины (VLSM, Variable Length Subnet Masks) ####################
==> Networks by Rebrain Основы IP адресации 2
		     Рассмотрение типичной топологии сети с использованием VLSM: 2:00:22 / 2:09:31    	     		
		     https://www.youtube.com/watch?v=SOZXLPvsFsQ&list=PL_jzYoo7u8dGpqTl6quYwZ_EFzmN75BXE&index=9

Разделение базового адресного пространства (базового сетевого адреса) на подсети разного размера, исходя из количества хостов в каждой подсети.


# ===================== Настройка IP-адреса =====================
Существует 2 основных способа назначения IP-адреса: статически (вручную) и динамически (автоматически по протоколу DHCP от DHCP-сервера).
В консоли Linux Ubuntu 20.04 настроить или изменить ip адрес можно несколькими способами. Основные из них:
    - Способ 1 — с помощью команд ip a (ip addr), ifconfig, и др (позволяет изменить и сохранить настройки вплоть до момента рестарта системы);
    - Способ 2 — с помощью конфигурационного файла /etc/network/interfaces;
    - Способ 3 — с помощью утилиты Netplan.

# ===================== Способ 1 — Настройка параметров интерфейса с помощью ifconfig / ip a =====================
# Выполненные настройки хранятся в оперативной памяти, следовательно сбросятся после перезагрузки системы.
# Чтобы изменения сохранились перманентно, первый вариант - их нужно описать в конфигурационном файле /etc/network/interfaces.

ifconfig <имя интерфейса> <ip адрес> netmask <маска в точечно-десятичном формате>
user@rebraime-vm:~$ ifconfig ens160 192.168.30.21 netmask 255.255.255.0 broadcast 192.168.30.255 up

# Те же настройки можно назначить командой ip address (alias: ip a)
ip address {add|change|replace} <ip_адрес>/<маска в виде префикса> dev <имя интерфейса>
user@rebraime-vm:~$ip a add 192.168.30.21/24 dev ens160

# ===================== Способ 2 — Изменение параметров конфигурации интерфейсов через /etc/network/interfaces =====================
user@rebraime-vm:~$ sudo nano /etc/network/interfaces

# определим конфигурацию сетевых интерфейсов:
auto lo ens160

# Loopback interface
iface lo inet loopback

# Interface ens160 configuration
iface ens160 inet static
  address 192.168.30.21
  netmask 255.255.255.0
  gateway 192.168.30.254
  dns-nameservers 8.8.8.8 8.8.4.4

Параметры созданной конфигурации:
    auto — говорит операционной системе, что интерфейс нужно активировать и настраивать при запуске;
    iface ens160 inet static — выбирает из всех интерфейсов указанный и определяет тип настройки — статический;
    address — ip адрес интерфейса;
    netmask — маска;
    gateway — шлюз по умолчанию;
    dns-nameservers — определяет IP-адреса DNS-серверов, которые будут использоваться для преобразования доменных имен в IP-адреса.

Минимальные настройки на интерфейсе включают только ip адрес и маску.
Для применения настроек достаточно либо перезапустить сервис networking (sudo /etc/init.d/networking restart или sudo systemctl restart networking) либо перезагрузить систему.

# ===================== Способ 3 — Настройка с помощью утилиты netplan.io =====================
# Одним из популярных способов конфигурации параметров сетевых интерфейсов в операционной системе Linux является использование утилиты netplan.io,
# где в формате YAML можно описать параметры всех сетевых адаптеров.

# Начиная с версии Ubuntu 18.04 LTS, Netplan входит в базовый образ системы по умолчанию и используется как основной инструмент настройки сетевых параметров.
# Иначе для установки утилиты необходимо выполнить команду:
user@rebrainme-vm:~$ sudo apt install netplan.io

# Так как netplan - это только утилита для настройки параметров, ей нужны службы операционной системы, которые данные настройки смогут применить.
# В терминах netplan такие службы называют renderer (рендеры). На данный момент это NetworkManager или NetworkD (Ubuntu Manpages: systemd-networkd.service).

# Файлы конфигурации, в которых описываются параметры сетевых адаптеров, расположены в директории: /etc/netplan/.
# Найдем конфигурационный файл и определим параметры сетевых интерфейсов.

# По умолчанию утилита netplan создает конфигурационный файл /etc/netplan/01-network-manager-all.yaml, допишем в него параметры интерфейсов,
# используя текстовый редактор emacs:
sudo emacs /etc/netplan/01-network-manager-all.yaml

# Изначально содержимое файла выглядит так:

# Let NetworkManager manage all devices on this system
network:
  version: 2
  renderer: NetworkManager

где

    network — блок, из которого будут браться параметры настройки интерфейсов;
    version — версия YAML для описания параметров;
    renderer — системная служба, которая будет обрабатывать и применять настройки.

# Допишем в файл параметры сетевых интерфейсов:
# Let NetworkManager manage all devices on this system
network:
  version: 2
  renderer: NetworkManager
  ethernets:
    ens160:
      dhcp4: false
      addresses:
        - 192.168.30.21/24
      nameservers:
        addresses:
          - 8.8.8.8
      routes:
        - to: default
          via: 192.168.30.254
    lo:
      renderer: networkd
      match:
        name: lo
      addresses:
        - 192.168.20.1/24

Описание структуры:

    настройки IP-адресов проводных интерфейсов указываются в ethernets (для VLAN, WiFi и прочего предназначены другие имена);
    способ настройки адресов (динамический или статический) определяется сопоставлением: dhcp4: true/false;
    в addresses определяется список IP-адресов, присвоенных интерфейсу (список указывается либо в [], либо с переходом на новую строку и использованием -);
    в nameservers указываются IP-адреса DNS-серверов;
    routes используется для добавления маршрутов, мы указали маршрут по умолчанию как 0.0.0.0/0 (все сети, default) и через (to) указали адрес маршрутизатора.

Для проверки синтаксиса и конфигурации используется команда sudo netplan try. Если в конфигурации допущены ошибки, вывод команды сообщит об этом. Для примения конфигурации используется команда sudo netplan apply.

Более подробную информацию о возможностях утилиты netplan.io можно получить по ссылке: Netplan — The network configuration abstraction renderer (https://netplan.io/)

############################## Установить сетевой адрес для устройства ##############################
ip a add 10.10.10.101/24 dev eth0

#sh mac address-table dynamic

Задание:

Дано: Сеть топологии "звезда", построенная на базе неуправляемых коммутаторов и состоящая из центрального коммутатора, к которому подключены еще 5 коммутаторов, к ним, в свою очередь, подключены 9 ПК.
При этом номер порта на центральном коммутаторе соответствует номеру коммутатора, подключенному к нему.
На ПК назначены IP адреса из подсети 192.168.1.0/24, при этом номер последнего октета равен номеру ПК, например 192.168.1.8 у ПК-8.
Но кое где совершены ошибки и недоработки, например, не подключен кабель, выключен интерфейс, и т.д. Исправьте их, и убедитесь, что есть связность между всеми хостами.

ip a add 192.168.1.1/24 dev eth0
ip a add 192.168.1.2/24 dev eth0
ip a add 192.168.1.3/24 dev eth0
ip a add 192.168.1.4/24 dev eth0
ip a add 192.168.1.5/24 dev eth0
ip a add 192.168.1.6/24 dev eth0
ip a add 192.168.1.7/24 dev eth0
ip a add 192.168.1.8/24 dev eth0

ip link set eth0 up

ip address del 192.168.1.2 dev eth0
ip address add 192.168.1.2 dev eth0

ip address del 192.168.136.114/24 dev enp6s0

# For setting an IP address, use it like this:
ip addr add [ip_address] dev [interface]
ip a add 192.168.1.1/24 dev eth0

# Выключить необходимый интерфейс:
ip link set eth0 down

# ВКЛЮЧИТЬ необходимый интерфейс:
ip link set eth0 up

ip link set eth0 down
ip address del 192.168.1.3/16 dev eth0

############################## NET 05: Логическая коммутация. Интерфейс в режиме моста ##############################
Под понятием "логическая коммутация" подразумевается внедрение в работу логических (программных) коммутаторов.
В ядре Linux есть встроенный программный (логический) L2-bridge. Его администрирование осуществляется утилитой brctl из пакета 'bridge-utils'.

Linux-бридж может комбинировать в себе две роли: роль коммутатора и брандмауэра (межсетевого экрана).
Комбинация коммутатора и брандмауэра выполняется с помощью инструмента ebtables (Ethernet bridge frame table administration).
Утилита ebtables используется для создания правил, которые анализируют и фильтруют Ethernet кадры. По сути это брандмауэр на канальном уровне.

Основные возможности ebtables:
    - фильтрация на уровне протокола Ethernet
    - фильтрация MAC-адресов
    - трансляция MAC-адресов (NAT)
    - ведение логов
    - счетчики кадров
    - возможность добавлять, удалять, вставлять правила, сбрасывать цепочки, обнулять счетчики

# Установка bridge-utils:
sudo apt-get install bridge-utils

# Проверяем, что утилита brctl установлена и работает:
brctl show

# Создаем бридж с именем rbr-br-01 и проверим командной brctl show, что бридж создался:
brctl addbr rbr-br-01
brctl show

# Добавляем интерфейсы eth1-eth3 в созданный bridge:
brctl addif rbr-br-01 eth1
brctl addif rbr-br-01 eth2
brctl addif rbr-br-01 eth3

# По умолчанию созданный бридж интерфейс в неактивном состоянии!
# Поэтому необходимо поднять интерфейс rbr-br-01 на машине rbr-br-node и проверить, что он в состоянии 'UP':
ip link set rbr-br-01 up   # или ifconfig rbr-br-01 up
ip address

# Просмотреть таблицу MAC-адресов созданного бриджа:
brctl showmacs rbr-br-01

# Анализ содержимого вывода команды 'brctl showmacs rbr-br-01' (анализ таблицы MAC-адресов):
Если в столбце is local стоит yes напротив MAC-адреса, это значит, что MAC-адрес относится к собственному интерфейсу непосредственно на Linux Bridge,
а если значение "no" - эти MAC-адреса принадлежат устройствам, которые подключаются к Linux Bridge с другой стороны (физические или виртуальные машины или контейнеры).
Под "ageing timer" (время жизни) понимается время в секундах, которое MAC-адрес будет находиться в CAM-таблице (forwarding database) бриджа с момента получения последнего
пришедшего кадра с этим адресом на порт.
В обычной жизни вам редко понадобится менять данные параметры, но при необходимости это можно сделать командой brctl setageing <brname> <time> (время указывается в секундах).


##################################################

apt update && apt-get install bridge-utils  # Установите bridge-utils на машине BR-TEST-01.
brctl addbr br-test-01                      # Добавьте с помощью утилиты brctl новый бридж на машину BR-TEST-01 с именем br-test-01.
brctl show                                  # Проверяем, что бридж создался

# Добавляем порты eth1-eth4 в созданный бридж 'br-test-01'.
brctl addif br-test-01 eth1
brctl addif br-test-01 eth2
brctl addif br-test-01 eth3
brctl addif br-test-01 eth4

# Проверяем, что в бридж добавлены все 4 порта.
brctl show

# По умолчанию созданный бридж интерфейс в неактивном состоянии!
# Поэтому необходимо поднять интерфейс rbr-br-01 на машине rbr-br-node и проверить, что он в состоянии 'UP':
ip link set br-test-01 up

# или с помощью ifconfig:
ifconfig br-test-01 up

# Просмотреть таблицу MAC-адресов созданного бриджа:
brctl showmacs br-test-01

# Добавляем время жизни MAC-адресов, равным 120 секунд, и проверяем, отключив любой хост, что MAC-адрес этого хоста исчез из таблицы. 
# brctl setageing <brname> <time> (время указывается в секундах).
brctl setageing rbr-br-01 12

############################## NET 06: Коммутация в виртуальной среде. Openv Switch ##############################
Виртуальный коммутатор OpenvSwitch (OVS)  используется как компонент архитектуры во многих платформах виртуализации.
Цель: разобраться, какие реализации виртуальных коммутаторов используются для коммутации, например, между виртуальными машинами или между контейнерами, как их настраивать.

############################## Основные компоненты OpenvSwitch: ##############################
    1) ovs-vswitchd — это демон, реализующий коммутатор вместе с сопутствующим модулем ядра Linux;
    2) ovsdb-server — облегченная база данных, которую ovs-vswitchd запрашивает для получения своей конфигурации;
    3) ovs-dpctl — инструмент для настройки модуля ядра для коммутатора;
    4) ovs-vsctl — утилита для запроса и обновления конфигурации ovs-vswitchd;
    5) ovs-appctl — утилита, которая отправляет команды для запуска демонов OpenvSwitch;
    6) ovs-vdocker — инструмент для управления связностью контейнеров Docker.

############################## Основные КОМАНДЫ OpenvSwitch: ##############################
    1) ovs-vsctl - этот инструмент используется для настройки и просмотра следующих операций на OVS:
       - конфигурация портов;
       - добавление/удаление bridge;
       - связывание и тегирование VLAN.
       
         Примеры команды:
       ovs-vsctl add-br br-name-1       # Эта команда создаст интерфейс в режиме моста (bridge) в БД коммутатора с именем "br-name-1"
       ovs-vsctl list bridge br-name-1  # Эта команда выведет подробную таблицу с параметрами бриджа "br-name-1"
       
    2) ovs-ofctl - инструмент cmd для администрирования и мониторинга коммутаторов OpenFlow.
         Примеры команды:
       ovs-ofctl dump-ports-desc br-name-1  # Выведет статистику портов бриджа с именем "br-name-1"
       
    3) ovs-dpctl - отображает потоки c пакетами, которые фактически прошли через систему в течение последних нескольких секунд.
    4) ovs-appctl - утилита для управления демонами (сервисами) Open vSwitch. Используется для настройки параметров модуля журнала, а также для просмотра потоков OpenFlow.
         Примеры команды:
      ovs-appctl bridge/dump-flows br-100   # Выводит потоки OpenFlow, включая скрытые. Полезная команда для устранения неполадок.
      ovs-appctl vlog/list                  # Перечисляет известные модули журнала и их уровни логирования.

############################## Настройка OVS на примере построения коммутации в контейнерах Docker c одним хостом: ##############################
########## Open vSwitch c одним бриджем и двумя контейнерами ##########
"container_1" (eth0: 172.25.0.2/24) <===> "container_2" (eth0: 172.25.0.3/24)
	    	   		      |
				      |
				  Open vSwitch
			====== "docker-ovsbr1" =====
			              |
				      |
			  eth0: 192.168.100.1/24

# Установка OpenvSwitch:
# Предварительно необходимо обновить список пакетов в системе:
sudo apt-get update

# Устанавливаем OpenvSwitch:
sudo apt-get install -y openvswitch-switch

# # Устанавливаем Docker. Минимальная установка docker для нашей конфигурации выглядит следующим образом:
sudo apt-get install -y docker.io
The following packages have unmet dependencies:
 containerd.io : Conflicts: containerd
E: Error, pkgProblemResolver::Resolve generated breaks, this may be caused by held packages.

# Переустановка docker: (причина - containerd.io conflicts containerd)
sudo apt-get remove containerd.io && sudo apt-get autoremove
sudo apt install docker.io docker-compose -y
systemctl start docker

#  Команда 'gpasswd' назначает пользователя в группу с некоторыми критериями безопасности (используется для администрирования /etc/group и /etc/gshadow).
sudo gpasswd -a $USER docker  # Adding user $USER  to group 'docker'

# Также нам потребуется загрузить образ ubuntu из официального репозитория Docker Hub, на основе которого будут созданы будущие контейнеры:
sudo docker pull ubuntu

# Если образ успешно загружен, его можно увидеть в списке с помощью команды "sudo docker images" или "sudo docker image ls":
sudo docker images
sudo docker image ls

# #################### Создание бриджа OVS: ####################
# Здесь мы добавим новый бридж OVS с именем "docker-ovsbr1" для подключения контейнеров в сети 172.25.0.0/24:
# ip =      172.25.0.0
# netmask = 255.255.255.0
# net_ip =  172.25.0.0
# bcast_ip = 172.25.0.255
# first_ip = 172.25.0.1
# last_ip =  172.25.0.254

# Создать новый бридж Open vSwitch (OVS) с именем "docker-ovsbr1" для подключения контейнеров в сети 172.25.0.0/24:
sudo ovs-vsctl add-br docker-ovsbr1

# Для работы с командой "ifconfig" устанавливаем пакет "net-tools":
sudo apt-get install net-tools

# С помощью команды ifconfig присваиваем ip-адрес и маску из отдельной сети 172.25.0.0/24, а также переводим созданный интерфейс в состояние UP:
sudo ifconfig docker-ovsbr1 172.25.0.1 netmask 255.255.255.0 up

# Проверим, создался ли новый бридж "docker-ovsbr1":
sudo ovs-vsctl show
kav@bqp:~$ sudo ovs-vsctl show
91f87741-de07-4c42-b1c1-8aad5caf52ae
    Bridge docker-ovsbr1   # <== Бридж был успешно 
        Port docker-ovsbr1
            Interface docker-ovsbr1
                type: internal
    ovs_version: "2.17.9"

############################## Запуск и настройка контейнера ##############################
1.1. Запустим 2 контейнера с именами "container1" и "container2" Ubuntu Docker:
sudo docker run -it --name container1 -d ubuntu /bin/bash
sudo docker run -it --name container2 -d ubuntu /bin/bash

1.2. Посмотрим, что получилось
# -a Show all containers (default shows just running)
docker ps -a
kav@bqp:~$ docker ps -a
CONTAINER ID   IMAGE          COMMAND       CREATED          STATUS                     PORTS     NAMES
403b0de902ae   ubuntu         "/bin/bash"   38 seconds ago   Up 38 seconds                        container2
470153715eb5   ubuntu         "/bin/bash"   44 seconds ago   Up 43 seconds                        container1
5aa7ea3cff8f   3db8720ecbf5   "bash"        2 weeks ago      Exited (127) 2 weeks ago             dreamy_gauss
475a24a10b72   hello-world    "/hello"      2 weeks ago      Exited (0) 2 weeks ago               sweet_joliot
0e241e00c21d   hello-world    "/hello"      2 weeks ago      Exited (0) 2 weeks ago               kind_perlman

# Вывести информацию ТОЛЬКО о ЗАПУЩЕННЫХ (running) контейнерах:
docker ps

1.3. Останавливаем контейнеры:
docker container stop container1
docker container stop container2

1.4. Проверяем вывод ifconfig с остановленными контейнерами (вывод представлен в сокращенном виде):
kav@bqp:~$ ifconfig
docker0: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500
docker-ovsbr1: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
enp42s0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
enp4s0: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500
lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
virbr0: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500

1.5. Запускаем уже существующие контейнеры:
sudo docker container start container1
sudo docker container start container2n

1.6. Снова проверяем вывод 'ifconfig' - теперь вывод дополнился 2-мя новыми интерфейсами:
veth5eef7af: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
vetha867122: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500

# Docker создал виртуальные интерфейсы veth[UNIQUE_ID]
# Нужно выяснить, к каким контейнерам относятся новые появившиеся виртуальные интерфейсы:
# https://stackoverflow.com/questions/37860936/find-out-which-network-interface-belongs-to-docker-container
docker exec -it container1 cat /sys/class/net/eth0/iflink

kav@bqp:~$ docker exec -it container1 cat /sys/class/net/eth0/iflink
17

# После этого выясняем соответствие:
kav@bqp:~$ ip address | grep 17:
17: veth5eef7af@if16: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue master docker0 state UP group default 

2. Соединим эти контейнеры с бриджем OpenvSwitch (OVS) с именем "docker-ovsbr1" через интерфейсы контейнеров "eth1", присвоим им адреса 
sudo ovs-docker add-port docker-ovsbr1 eth1 container1 --ipaddress=172.25.0.2/24
sudo ovs-docker add-port docker-ovsbr1 eth1 container2 --ipaddress=172.25.0.3/24

3. Посмотрим, что у нас получилось:
sudo ovs-vsctl show

kav@bqp:~/bash_scripts$ sudo ovs-vsctl show
91f87741-de07-4c42-b1c1-8aad5caf52ae
    Bridge docker-ovsbr1
        Port bf0d39c02c894_l
            Interface bf0d39c02c894_l
        Port b1e440b2884d4_l
            Interface b1e440b2884d4_l
        Port docker-ovsbr1
            Interface docker-ovsbr1
                type: internal
    ovs_version: "2.17.9"


4. Определим IP-адреса контейнеров:
sudo docker exec container1 ifconfig eth1

# Указанная команда может отсутствовать внутри контейнера - чтобы решить эту проблему нужно внутри контейнера выполнить установку необходимых пакетов командой:
sudo docker exec container1 bash -c 'apt update -qq && apt install -y iputils-ping net-tools'
sudo docker exec container2 bash -c 'apt update -qq && apt install -y iputils-ping net-tools'

5. Пробуем выполнить пинг-запрос с container1 (172.25.0.2) на container2 (172.25.0.3):
sudo docker exec container1 ping 172.25.0.3

# Как видим пинг до container2 через бридж docker-ovsbr1 успешно проходит:
kav@bqp:~/bash_scripts$ sudo docker exec container1 ping 172.25.0.3
PING 172.25.0.3 (172.25.0.3) 56(84) bytes of data.
64 bytes from 172.25.0.3: icmp_seq=1 ttl=64 time=0.300 ms
64 bytes from 172.25.0.3: icmp_seq=2 ttl=64 time=0.067 ms
64 bytes from 172.25.0.3: icmp_seq=3 ttl=64 time=0.059 ms

# TODO:
А теперь усложним наш пример.
Представьте, что нам поставили задачу добавить еще два контейнера, но с отдельной сетью 172.35.0.0/24,
при этом сделать так, чтобы контейнеры из одной сети могли общаться с контейнерами из другой.
